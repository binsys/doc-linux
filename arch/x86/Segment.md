80x86保护模式编程
================================================================================

内存管理寄存器
--------------------------------------------------------------------------------

处理器提供了4个内存管理寄存器: GDTR, LDTR, IDTR, TR.
用于指定内存分段管理所用系统表的基地址，处理器为这些寄存器的加载和保存提供了特定的指令.
如下图所示:

https://github.com/leeminghao/doc-linux/blob/master/arch/x86/gdtr_idtr_tr_ldtr.jpg

### 全局描述符表寄存器GDTR

GDTR寄存器: 用于存放全局描述符表GDT的32位的线性基地址和16位的表限长值。
基地址指定GDT表中字节0在线性地址空间中的地址，表长度指明GDT表的字节长度值。

指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。

在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。
在保护模式初始化过程中必须给GDTR加载一个新值。

### 中断描述符表寄存器IDTR

IDTR寄存器: 用于存放中断描述符表IDT的32位线性基地址和16位表长度值。
指令LIDT和SIDT分别用于加载和保存IDTR寄存器的内容。

在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。

### 局部描述符表寄存器LDTR

LDTR寄存器: 用于存放局部描述符表LDT的32位线性基地址、16位段限长和描述符属性值。

指令LLDT和SLDT分别用于加载和保存LDTR寄存器的段描述符部分。
包含LDT表的段必须在GDT表中有一个段描述符项。

* 当使用LLDT指令把含有LDT表段的选择符加载进LDTR时，LDT段描述符的段基地址、段限长度以及描述符属性
  会被自动地加载到LDTR中。

* 当进行任务切换时，处理器会把新任务LDT的段选择符和段描述符自动地加载进LDTR中。

在机器加电或处理器复位后，段选择符和基地址被默认地设置为0，而段长度被设置成0xFFFF。

### 任务寄存器TR

TR寄存器: 用于存放当前任务TSS段的16位段选择符、32位基地址、16位段长度和描述符属性值。
它引用GDT表中的一个TSS类型的描述符, 指令LTR和STR分别用于加载和保存TR寄存器的段选择符部分。

* 当使用LTR指令把选择符加载进任务寄存器时，TSS描述符中的段基地址、段限长度以及描述符属性会被自动
  加载到任务寄存器中。

* 当执行任务切换时，处理器会把新任务的TSS的段选择符和段描述符自动加载进任务寄存器TR中。

控制寄存器
--------------------------------------------------------------------------------

控制寄存器（CR0～CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性.
如下图所示:

https://github.com/leeminghao/doc-linux/blob/master/arch/x86/cr.jpg

* CR0中含有控制处理器操作模式和状态的系统控制标志；
* CR1保留不用；
* CR2含有导致页错误的线性地址；
* CR3中含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器PDBR.

### CR0中保护控制位

* PE: CR0的位0是启用保护（Protection Enable）标志。
  当设置该位时即开启了保护模式；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用
  分页机制。若要启用分页机制，那么PE和PG标志都要置位。

* PG: CR0的位31是分页（Paging）标志。
  当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址。
  在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位。

* WP：对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志。
  当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作；
  当该位复位时则反之。该标志有利于UNIX类操作系统在创建进程时实现写时复制（Copy on Write）技术。

启用保护模式PE（Protected Enable）位（位0）和开启分页PG（Paging）位（位31）分别用于控制分段和分页机制。

PE用于控制分段机制:

* 如果PE=1，处理器就工作在开启分段机制环境下，即运行在保护模式下。
* 如果PE=0，则处理器关闭了分段机制，并如同8086工作于实地址模式下。

PG用于控制分页机制:

* 如果PG=1，则开启了分页机制。
* 如果PG=0，分页机制被禁止，此时线性地址被直接作为物理地址使用。


* 如果PE=0、PG=0，处理器工作在实地址模式下；
* 如果PG=0、PE=1，处理器工作在没有开启分页机制的保护模式下；
* 如果PG=1、PE=0，此时由于不在保护模式下不能启用分页机制，因此处理器会产生一个一般保护异常，即这种标志组合无效；
* 如果PG=1、PE=1，则处理器工作在开启了分页机制的保护模式下。

**注意**: 当改变PE和PG位时，必须小心。只有当执行程序至少有部分代码和数据在线性地址空间和物理地址
空间中具有相同地址时，我们才能改变PG位的设置。此时这部分具有相同地址的代码在分页和未分页世界之间
起着桥梁的作用。无论是否开启分页机制，这部分代码都具有相同的地址。另外，在开启分页（PG=1）之前
必须先刷新页高速缓冲TLB。

在修改该了PE位之后程序必须立刻使用一条跳转指令，以刷新处理器执行管道中已经获取的不同模式下的任何
指令。在设置PE位之前，程序必须初始化几个系统段和控制寄存器。在系统刚上电时，处理器被复位成PE=0和
PG=0（即实模式状态），以允许引导代码在启用分段和分页机制之前能够初始化这些寄存器和数据结构。

### CR3

* CR3含有存放页目录表页面的物理地址，因此CR3也被称为PDBR。
  因为页目录表页面是页对齐的，  所以该寄存器只有高20位是有效的。
  而低12位保留供更高级处理器使用，因此在往CR3中加载一个新值时低12位必须设置为0。

使用MOV指令加载CR3时具有让页高速缓冲无效的副作用。为了减少地址转换所要求的总线周期数量，
最近访问的页目录和页表会被存放在处理器的页高速缓冲器件中，该缓冲器件被称为转换查找缓冲区
（Translation Lookaside Buffer，TLB）。只有当TLB中不包含要求的页表项时才会使用额外的总线周期从
内存中读取页表项。

即使CR0中的PG位处于复位状态（PG=0），我们也能先加载CR3。以允许对分页机制进行初始化。
当切换任务时，CR3的内容也会随之改变。但是如果新任务的CR3值与原任务的一样，处理器就无需刷新页
高速缓冲。这样共享页表的任务可以执行得更快。

### CR2

CR2用于出现页异常时报告出错信息。在报告页异常时，处理器会把引起异常的线性地址存放在CR2中。
因此操作系统中的页异常处理程序可以通过检查CR2的内容来确定线性地址空间中哪一个页面引发了异常。