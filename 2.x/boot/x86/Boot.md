Linux Boot
================================================================================

加载BIOS
--------------------------------------------------------------------------------

当你打开计算机电源，计算机会首先加载BIOS信息，BIOS信息是如此的重要，以至于计算机必须在最开始就找到它。
这是因为BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等。在此之后，
计算机心里就有谱了，知道应该去读取哪个硬件设备了。在BIOS将系统的控制权交给硬盘第一个扇区之后，就开始由Linux来控制系统了。

读取MBR
--------------------------------------------------------------------------------

硬盘上第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即主引导记录，它的大小是512字节，可里面却存放了预启动信息、分区表信息。
可分为两部分：
* 第一部分为引导(PRE-BOOT)区，占了446个字节;
* 第二部分为分区表(PARTITION PABLE)，共有66个字节，记录硬盘的分区信息。
预引导区的作用之一是找到标记为活动(ACTIVE)的分区，并将活动分区的引导区读入内存。

系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0×7c00地址所在的物理内存中。
其实被复制到物理内存的内容就是Boot Loader，而具体到你的电脑，那就是lilo或者grub了。

Boot Loader
--------------------------------------------------------------------------------

Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，
从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。
通常，Bootloade:是严重地依赖于硬件而实现的，不同体系结构的系统存在着不同的Boot Loader。
Linux的引导扇区内容是采用汇编语言编写的程序，其源代码在arch/i386/boot中(不同体系的CPU有其各自的boot目录)，有4个程序文件：
* bootsect.S，引导扇区的主程序，汇编后的代码不超过512字节，即一个扇区的大小
* setup.S， 引导辅助程序
* edd.S,辅助程序的一部分，用于支持BIOS增强磁盘设备服务
* video.S,辅助程序的另一部分，用于引导时的屏幕显示
Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader，这里以Grub为例来讲解吧。
系统读取内存中的grub配置信息(一般为menu.lst或grub.lst)，并依照此配置信息来启动不同的操作系统。

加载内核
--------------------------------------------------------------------------------

根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。此时，屏幕一般会输出“Uncompressing Linux”的提示。
当解压缩内核完成后，屏幕输出“OK, booting the kernel”。系统将解压后的内核放置在内存之中，并调用start_kernel()函数来
启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。
start_kenrel()定义在init/main.c中，它就类似于一般可执行程序中的main()函数，
系统在此之前所做的仅仅是一些能让内核程序最低限度执行的初始化操作，真正的内核初始化过程是从这里才开始。
函数start_kerenl()将会调用一系列的初始化函数，用来完成内核本身的各方面设置，目的是最终建立起基本完整的Linux核心环境。