e2fsck
========================================

sources: android_platform_external_e2fsprogs/e2fsck

用法
----------------------------------------

e2fsck - check a Linux second extended file system

### SYNOPSIS

```
e2fsck [ -pacnyrdfvstDFSV ] [ -b superblock ] [ -B blocksize ] [ -l|-L bad_blocks_file ] [ -C fd ] [ -j external-journal ] [ -E extended_options ] device
``

### DESCRIPTION

```
e2fsck is used to check a Linux second extended file system (ext2fs). E2fsck also supports ext2 filesystems countaining a journal, which are also sometimes known as ext3 filesystems, by first applying the journal to the filesystem before continuing with normal e2fsck processing. After the journal has been applied, a filesystem will normally be marked as clean. Hence, for ext3 filesystems, e2fsck will normally run the journal and exit, unless its superblock indicates that further checking is required.

device is the device file where the filesystem is stored (e.g. /dev/hdc1).
```

### OPTIONS

```
-a
    This option does the same thing as the -p option. It is provided for backwards compatibility only; it is suggested that people use -p option whenever possible.
-b superblock
    Instead of using the normal superblock, use an alternative superblock specified by superblock. This option is normally used when the primary superblock has been corrupted. The location of the backup superblock is dependent on the filesystem's blocksize. For filesystems with 1k blocksizes, a backup superblock can be found at block 8193; for filesystems with 2k blocksizes, at block 16384; and for 4k blocksizes, at block 32768.
    Additional backup superblocks can be determined by using the mke2fs program using the -n option to print out where the superblocks were created. The -b option to mke2fs, which specifies blocksize of the filesystem must be specified in order for the superblock locations that are printed out to be accurate.
    If an alternative superblock is specified and the filesystem is not opened read-only, e2fsck will make sure that the primary superblock is updated appropriately upon completion of the filesystem check.
-B blocksize
    Normally, e2fsck will search for the superblock at various different block sizes in an attempt to find the appropriate block size. This search can be fooled in some cases. This option forces e2fsck to only try locating the superblock at a particular blocksize. If the superblock is not found, e2fsck will terminate with a fatal error.
-c
    This option causes e2fsck to run the badblocks(8) program to find any blocks which are bad on the filesystem, and then marks them as bad by adding them to the bad block inode. If this option is specified twice, then the bad block scan will be done using a non-destructive read-write test.
-C
    This option causes e2fsck to write completion information to the specified file descriptor so that the progress of the filesystem check can be monitored. This option is typically used by programs which are running e2fsck. If the file descriptor specified is 0, e2fsck will print a completion bar as it goes about its business. This requires that e2fsck is running on a video console or terminal.
-d
    Print debugging output (useless unless you are debugging e2fsck).
-D
    Optimize directories in filesystem. This option causes e2fsck to try to optimize all directories, either by reindexing them if the filesystem supports directory indexing, or by sorting and compressing directories for smaller directories, or for filesystems using traditional linear directories.
-E extended_options
    Set e2fsck extended options. Extended options are comma separated, and may take an argument using the equals ('=') sign. The following options are supported:

        ea_ver=extended_attribute_version
            Assume the format of the extended attribute blocks in the filesystem is the specified version number. The version number may be 1 or 2. The default extended attribute version format is 2.

-f
    Force checking even if the file system seems clean.
-F
    Flush the filesystem device's buffer caches before beginning. Only really useful for doing e2fsck time trials.
-j external-journal
    Set the pathname where the external-journal for this filesystem can be found.
-l filename
    Add the block numbers listed in the file specified by filename to the list of bad blocks. The format of this file is the same as the one generated by the badblocks(8) program. Note that the block numbers are based on the blocksize of the filesystem. Hence, badblocks(8) must be given the blocksize of the filesystem in order to obtain correct results. As a result, it is much simpler and safer to use the -c option to e2fsck, since it will assure that the correct parameters are passed to the badblocks program.
-L filename
    Set the bad blocks list to be the list of blocks specified by filename. (This option is the same as the -l option, except the bad blocks list is cleared before the blocks listed in the file are added to the bad blocks list.)
-n
    Open the filesystem read-only, and assume an answer of `no' to all questions. Allows e2fsck to be used non-interactively. (Note: if the -c, -l, or -L options are specified in addition to the -n option, then the filesystem will be opened read-write, to permit the bad-blocks list to be updated. However, no other changes will be made to the filesystem.)
-p
    Automatically repair ("preen") the file system without any questions.
-r
    This option does nothing at all; it is provided only for backwards compatibility.
-s
    This option will byte-swap the filesystem so that it is using the normalized, standard byte-order (which is i386 or little endian). If the filesystem is already in the standard byte-order, e2fsck will take no action.
-S
    This option will byte-swap the filesystem, regardless of its current byte-order.
-t
    Print timing statistics for e2fsck. If this option is used twice, additional timing statistics are printed on a pass by pass basis.
-v
    Verbose mode.
-V
    Print version information and exit.
-y
    Assume an answer of `yes' to all questions; allows e2fsck to be used non-interactively.
```

### EXIT CODE

```
The exit code returned by e2fsck is the sum of the following conditions:
0 - No errors
1 - File system errors corrected
2 - File system errors corrected, system should
be rebooted
4 - File system errors left uncorrected
8 - Operational error
16 - Usage or syntax error
32 - E2fsck canceled by user request
128 - Shared library error
```

### SIGNALS

The following signals have the following effect when sent to e2fsck.

* SIGUSR1

```
    This signal causes e2fsck to start displaying a completion bar. (See discussion of the -C option.)
```
* SIGUSR2

```
    This signal causes e2fsck to stop displaying a completion bar.
```

数据结构
----------------------------------------

### e2fsck_t

path: e2fsck/e2fsck.h
```
/*
 * This is the global e2fsck structure.
 */
typedef struct e2fsck_struct *e2fsck_t;

#define MAX_EXTENT_DEPTH_COUNT 5

struct e2fsck_struct {
    ext2_filsys fs; // 描述ex2文件系统信息数据结构
    const char *program_name; // 当前执行程序的名称.
    char *filesystem_name;
    char *device_name;
    char *io_options;
    FILE *logf;
    char *log_fn;
    int flags;   /* E2fsck internal flags */
    int options; // 可选项
    int blocksize; /* blocksize */
    blk64_t use_superblock; /* sb requested by user */
    blk64_t    superblock;    /* sb used to open fs */
    blk64_t    num_blocks;    /* Total number of blocks */
    blk64_t free_blocks;
    ino_t    free_inodes;
    int    mount_flags;
    blkid_cache blkid;    /* blkid cache */

#ifdef HAVE_SETJMP_H
    jmp_buf    abort_loc;
#endif
    unsigned long abort_code;

    int (*progress)(e2fsck_t ctx, int pass, unsigned long cur,
            unsigned long max);

    ext2fs_inode_bitmap inode_used_map; /* Inodes which are in use */
    ext2fs_inode_bitmap inode_bad_map; /* Inodes which are bad somehow */
    ext2fs_inode_bitmap inode_dir_map; /* Inodes which are directories */
    ext2fs_inode_bitmap inode_bb_map; /* Inodes which are in bad blocks */
    ext2fs_inode_bitmap inode_imagic_map; /* AFS inodes */
    ext2fs_inode_bitmap inode_reg_map; /* Inodes which are regular files*/

    ext2fs_block_bitmap block_found_map; /* Blocks which are in use */
    ext2fs_block_bitmap block_dup_map; /* Blks referenced more than once */
    ext2fs_block_bitmap block_ea_map; /* Blocks which are used by EA's */

    /*
     * Inode count arrays
     */
    ext2_icount_t    inode_count;
    ext2_icount_t inode_link_info;

    ext2_refcount_t    refcount;
    ext2_refcount_t refcount_extra;

    /*
     * Array of flags indicating whether an inode bitmap, block
     * bitmap, or inode table is invalid
     */
    int *invalid_inode_bitmap_flag;
    int *invalid_block_bitmap_flag;
    int *invalid_inode_table_flag;
    int invalid_bitmaps;    /* There are invalid bitmaps/itable */

    /*
     * Block buffer
     */
    char *block_buf;

    /*
     * For pass1_check_directory and pass1_get_blocks
     */
    ext2_ino_t stashed_ino;
    struct ext2_inode *stashed_inode;

    /*
     * Location of the lost and found directory
     */
    ext2_ino_t lost_and_found;
    int bad_lost_and_found;

    /*
     * Directory information
     */
    struct dir_info_db    *dir_info;

    /*
     * Indexed directory information
     */
    int        dx_dir_info_count;
    int        dx_dir_info_size;
    struct dx_dir_info *dx_dir_info;

    /*
     * Directories to hash
     */
    ext2_u32_list    dirs_to_hash;

    /*
     * Tuning parameters
     */
    int process_inode_size;
    int inode_buffer_blocks;
    unsigned int htree_slack_percentage;

    /*
     * ext3 journal support
     */
    io_channel    journal_io;
    char    *journal_name;

    /*
     * Ext4 quota support
     */
    quota_ctx_t qctx;
#ifdef RESOURCE_TRACK
    /*
     * For timing purposes
     */
    struct resource_track    global_rtrack;
#endif

    /*
     * How we display the progress update (for unix)
     */
    int progress_fd;
    int progress_pos;
    int progress_last_percent;
    unsigned int progress_last_time;
    int interactive;    /* Are we connected directly to a tty? */
    char start_meta[2], stop_meta[2];

    /* File counts */
    __u32 fs_directory_count;
    __u32 fs_regular_count;
    __u32 fs_blockdev_count;
    __u32 fs_chardev_count;
    __u32 fs_links_count;
    __u32 fs_symlinks_count;
    __u32 fs_fast_symlinks_count;
    __u32 fs_fifo_count;
    __u32 fs_total_count;
    __u32 fs_badblocks_count;
    __u32 fs_sockets_count;
    __u32 fs_ind_count;
    __u32 fs_dind_count;
    __u32 fs_tind_count;
    __u32 fs_fragmented;
    __u32 fs_fragmented_dir;
    __u32 large_files;
    __u32 fs_ext_attr_inodes;
    __u32 fs_ext_attr_blocks;
    __u32 extent_depth_count[MAX_EXTENT_DEPTH_COUNT];

    /* misc fields */
    time_t now;
    time_t time_fudge;    /* For working around buggy init scripts */
    int ext_attr_ver;
    profile_t    profile;
    int blocks_per_page;

    /*
     * For the use of callers of the e2fsck functions; not used by
     * e2fsck functions themselves.
     */
    void *priv_data;
};
```

### ext2_filsys

path: lib/ext2fs/ext2fs.h
```
typedef struct struct_ext2_filsys *ext2_filsys;
...
struct struct_ext2_filsys {
    errcode_t    magic;
    io_channel    io;
    int   flags;
    char *   device_name;
    struct ext2_super_block    *     super;
    unsigned int    blocksize;
    int   fragsize;
    dgrp_t   group_desc_count;
    unsigned long    desc_blocks;
    struct ext2_group_desc *    group_desc;
    int   inode_blocks_per_group;
    ext2fs_inode_bitmap   inode_map;
    ext2fs_block_bitmap   block_map;
    errcode_t (*get_blocks)(ext2_filsys fs, ext2_ino_t ino, blk_t *blocks);
    errcode_t (*check_directory)(ext2_filsys fs, ext2_ino_t ino);
    errcode_t (*write_bitmaps)(ext2_filsys fs);
    errcode_t (*read_inode)(ext2_filsys fs, ext2_ino_t ino,
                            struct ext2_inode *inode);
    errcode_t (*write_inode)(ext2_filsys fs, ext2_ino_t ino,
                             struct ext2_inode *inode);
    ext2_badblocks_list   badblocks;
    ext2_dblist    dblist;
    __u32   stride;    /* for mke2fs */
    struct ext2_super_block *    orig_super;
    struct ext2_image_hdr *   image_header;
    __u32   umask;
    time_t   now;
    /*
     * Reserved for future expansion
     */
    __u32   reserved[7];

    /*
     * Reserved for the use of the calling application.
     */
    void *   priv_data;

    /*
     * Inode cache
     */
    struct ext2_inode_cache   *icache;
    io_channel    image_io;

    /*
     * More callback functions
     */
    errcode_t (*get_alloc_block)(ext2_filsys fs, blk64_t goal,
                                 blk64_t *ret);
    void (*block_alloc_stats)(ext2_filsys fs, blk64_t blk, int inuse);
};
```

e2fsck工具执行流程:
----------------------------------------

path: e2fsck/unix.c

### PRS

```
int main (int argc, char *argv[])
{
    errcode_t    retval = 0, retval2 = 0, orig_retval = 0;
    int        exit_value = FSCK_OK;
    ext2_filsys    fs = 0;
    io_manager    io_ptr;
    struct ext2_super_block *sb;
    const char    *lib_ver_date;
    int        my_ver, lib_ver;
    e2fsck_t    ctx;
    blk64_t        orig_superblock;
    struct problem_context pctx;
    int flags, run_result;
    int journal_size;
    int sysval, sys_page_size = 4096;
    int old_bitmaps;
    __u32 features[3];
    char *cp;
    int qtype = -99;  /* quota type */

    ...

    retval = PRS(argc, argv, &ctx);
    ...
}
```

path: e2fsck/unix.c

```
static errcode_t PRS(int argc, char *argv[], e2fsck_t *ret_ctx)
{
    int        flush = 0;
    int        c, fd;
#ifdef MTRACE
    extern void    *mallwatch;
#endif
    e2fsck_t    ctx;
    errcode_t    retval;
#ifdef HAVE_SIGNAL_H
    struct sigaction    sa;
#endif
    char        *extended_opts = 0;
    char        *cp;
    int         res;        /* result of sscanf */
#ifdef CONFIG_JBD_DEBUG
    char         *jbd_debug;
#endif

    // 1.分配一个e2fsck_t类型的context.
    retval = e2fsck_allocate_context(&ctx);
    if (retval)
        return retval;

    *ret_ctx = ctx;

    ...

    // 2.初始化context的program_name
    if (argc && *argv)
        ctx->program_name = *argv;
    else
        ctx->program_name = "e2fsck";

    // 3.解析选项
    while ((c = getopt (argc, argv, "panyrcC:B:dE:fvtFVM:b:I:j:P:l:L:N:SsDk")) != EOF)
        switch (c) {
        // -C 将检查过程的信息完整记录在file descriptor中，使得整个检查过程都能完整监控。
        case 'C':
            ctx->progress = e2fsck_update_progress;
            res = sscanf(optarg, "%d", &ctx->progress_fd);
            ...
            /* Validate the file descriptor to avoid disasters */
            fd = dup(ctx->progress_fd);
            ...
            break;
        case 'D': // 设置E2F_OPT_COMPRESS_DIRS选项
            ctx->options |= E2F_OPT_COMPRESS_DIRS;
            break;
        case 'E': // 扩展选项
            extended_opts = optarg;
            break;
        case 'p': // -p/-a : 如果检查有错则自动修复
        case 'a':
            if (ctx->options & (E2F_OPT_YES|E2F_OPT_NO)) {
            conflict_opt:
                fatal_error(ctx,
                _("Only one of the options -p/-a, -n or -y may be specified."));
            }
            ctx->options |= E2F_OPT_PREEN;
            break;
        // -n 以只读模式开启文件系统，并采取非互动方式执行，所有的问题对话均设置以"no"回答。
        case 'n':
            if (ctx->options & (E2F_OPT_YES|E2F_OPT_PREEN))
                goto conflict_opt;
            ctx->options |= E2F_OPT_NO;
            break;
        // -y 采取非互动方式执行，所有的问题均设置以"yes"回答。
        case 'y':
            if (ctx->options & (E2F_OPT_PREEN|E2F_OPT_NO))
                goto conflict_opt;
            ctx->options |= E2F_OPT_YES;
            break;
        case 't':
            ...
            break;
        // -c 一并执行badblocks，以标示损坏的区块。
        case 'c':
            if (cflag++)
                ctx->options |= E2F_OPT_WRITECHECK;
            ctx->options |= E2F_OPT_CHECKBLOCKS;
            break;
        case 'r':
            /* What we do by default, anyway! */
            break;
        // -b <superblock> 指定superblock，而不使用预设的superblock。
        case 'b':
            res = sscanf(optarg, "%llu", &ctx->use_superblock);
            if (res != 1)
                goto sscanf_err;
            ctx->flags |= E2F_FLAG_SB_SPECIFIED;
            break;
        // -B <区块大小> 指定区块的大小，单位为字节。
        case 'B':
            ctx->blocksize = atoi(optarg);
            break;
        case 'I':
            res = sscanf(optarg, "%d", &ctx->inode_buffer_blocks);
            if (res != 1)
                goto sscanf_err;
            break;
        case 'j':
            ctx->journal_name = blkid_get_devname(ctx->blkid,
                                  optarg, NULL);
            if (!ctx->journal_name) {
                com_err(ctx->program_name, 0,
                    _("Unable to resolve '%s'"),
                    optarg);
                fatal_error(ctx, 0);
            }
            break;
        case 'P':
            res = sscanf(optarg, "%d", &ctx->process_inode_size);
            if (res != 1)
                goto sscanf_err;
            break;
        // 先清除损坏区块列表，再将文件中指定的区块加到损坏区块列表。
        // 因此损坏区块列表的区块跟文件中指定的区块是一样的。
        case 'L':
            replace_bad_blocks++;
        // 将文件中指定的区块加到损坏区块列表。
        case 'l':
            if (bad_blocks_file)
                free(bad_blocks_file);
            bad_blocks_file = string_copy(ctx, optarg, 0);
            break;
        // -d 显示排错信息
        case 'd':
            ctx->options |= E2F_OPT_DEBUG;
            break;
        // -f 即使文件系统没有错误迹象，仍强制地检查正确性。
        case 'f':
            ctx->options |= E2F_OPT_FORCE;
            break;
        // 执行前先清除设备的缓冲区。
        case 'F':
            flush = 1;
            break;
        case 'v':
            verbose = 1;
            break;
        case 'V':
            show_version_only = 1;
            break;
#ifdef MTRACE
        case 'M':
            mallwatch = (void *) strtol(optarg, NULL, 0);
            break;
#endif
        case 'N':
            ctx->device_name = string_copy(ctx, optarg, 0);
            break;
        case 'k':
            keep_bad_blocks++;
            break;
        default:
            usage(ctx);
        }
        ...

    if (ctx->options & E2F_OPT_NO)
        ctx->options |= E2F_OPT_READONLY;

    ctx->io_options = strchr(argv[optind], '?');
    if (ctx->io_options)
        *ctx->io_options++ = 0;

    // 4. 将context的filesystem_name指向需要检查的设备名称.
    ctx->filesystem_name = blkid_get_devname(ctx->blkid, argv[optind], 0);

    ...

    if (extended_opts)
        parse_extended_opts(ctx, extended_opts);

    // 5. 初始化context的profile
    if ((cp = getenv("E2FSCK_CONFIG")) != NULL)
        config_fn[0] = cp;
    profile_set_syntax_err_cb(syntax_err_report);
    profile_init(config_fn, &ctx->profile);

    // 6. 初步处理预先设置的部分选项
    profile_get_boolean(ctx->profile, "options", "report_time", 0, 0,
                &c);
    if (c)
        ctx->options |= E2F_OPT_TIME | E2F_OPT_TIME2;
    profile_get_boolean(ctx->profile, "options", "report_verbose", 0, 0,
                &c);
    if (c)
        verbose = 1;

    /* Turn off discard in read-only mode */
    if ((ctx->options & E2F_OPT_NO) &&
        (ctx->options & E2F_OPT_DISCARD))
        ctx->options &= ~E2F_OPT_DISCARD;

    if (flush) {
        fd = open(ctx->filesystem_name, O_RDONLY, 0);
        if (fd < 0) {
            com_err("open", errno,
                _("while opening %s for flushing"),
                ctx->filesystem_name);
            fatal_error(ctx, 0);
        }
        if ((retval = ext2fs_sync_device(fd, 1))) {
            com_err("ext2fs_sync_device", retval,
                _("while trying to flush %s"),
                ctx->filesystem_name);
            fatal_error(ctx, 0);
        }
        close(fd);
    }
    if (cflag && bad_blocks_file) {
        fprintf(stderr, "%s", _("The -c and the -l/-L options may not "
                    "be both used at the same time.\n"));
        exit(FSCK_USAGE);
    }

    ...
}
```

path: path: e2fsck/unix.c

```
int main (int argc, char *argv[])
{

    reserve_stdio_fds();

    set_up_logging(ctx);
    if (ctx->logf) {
        int i;
        fputs("E2fsck run: ", ctx->logf);
        for (i = 0; i < argc; i++) {
            if (i)
                fputc(' ', ctx->logf);
            fputs(argv[i], ctx->logf);
        }
        fputc('\n', ctx->logf);
    }

    init_resource_track(&ctx->global_rtrack, NULL);
    if (!(ctx->options & E2F_OPT_PREEN) || show_version_only)
        log_err(ctx, "e2fsck %s (%s)\n", my_ver_string,
             my_ver_date);

    if (show_version_only) {
        log_err(ctx, _("\tUsing %s, %s\n"),
            error_message(EXT2_ET_BASE), lib_ver_date);
        exit(FSCK_OK);
    }

    check_mount(ctx);

    if (!(ctx->options & E2F_OPT_PREEN) &&
        !(ctx->options & E2F_OPT_NO) &&
        !(ctx->options & E2F_OPT_YES)) {
        if (!ctx->interactive)
            fatal_error(ctx,
                    _("need terminal for interactive repairs"));
    }
    ctx->superblock = ctx->use_superblock;

    flags = EXT2_FLAG_SKIP_MMP;
restart:
#ifdef CONFIG_TESTIO_DEBUG
    if (getenv("TEST_IO_FLAGS") || getenv("TEST_IO_BLOCK")) {
        io_ptr = test_io_manager;
        test_io_backing_manager = unix_io_manager;
    } else
#endif
        io_ptr = unix_io_manager;
    flags |= EXT2_FLAG_NOFREE_ON_ERROR;
    profile_get_boolean(ctx->profile, "options", "old_bitmaps", 0, 0,
                &old_bitmaps);
    if (!old_bitmaps)
        flags |= EXT2_FLAG_64BITS;
    if ((ctx->options & E2F_OPT_READONLY) == 0) {
        flags |= EXT2_FLAG_RW;
        if (!(ctx->mount_flags & EXT2_MF_ISROOT &&
              ctx->mount_flags & EXT2_MF_READONLY))
            flags |= EXT2_FLAG_EXCLUSIVE;
        if ((ctx->mount_flags & EXT2_MF_READONLY) &&
            (ctx->options & E2F_OPT_FORCE))
            flags &= ~EXT2_FLAG_EXCLUSIVE;
    }

    retval = try_open_fs(ctx, flags, io_ptr, &fs);

    if (!ctx->superblock && !(ctx->options & E2F_OPT_PREEN) &&
        !(ctx->flags & E2F_FLAG_SB_SPECIFIED) &&
        ((retval == EXT2_ET_BAD_MAGIC) ||
         (retval == EXT2_ET_CORRUPT_SUPERBLOCK) ||
         ((retval == 0) && (retval2 = ext2fs_check_desc(fs))))) {
        if (retval) {
            pctx.errcode = retval;
            fix_problem(ctx, PR_0_OPEN_FAILED, &pctx);
        }
        if (retval2) {
            pctx.errcode = retval2;
            fix_problem(ctx, PR_0_CHECK_DESC_FAILED, &pctx);
        }
        pctx.errcode = 0;
        if (retval2 == ENOMEM || retval2 == EXT2_ET_NO_MEMORY) {
            retval = retval2;
            goto failure;
        }
        if (fs->flags & EXT2_FLAG_NOFREE_ON_ERROR) {
            ext2fs_free(fs);
            fs = NULL;
        }
        if (!fs || (fs->group_desc_count > 1)) {
            log_out(ctx, _("%s: %s trying backup blocks...\n"),
                ctx->program_name,
                retval ? _("Superblock invalid,") :
                _("Group descriptors look bad..."));
            orig_superblock = ctx->superblock;
            get_backup_sb(ctx, fs, ctx->filesystem_name, io_ptr);
            if (fs)
                ext2fs_close(fs);
            orig_retval = retval;
            retval = try_open_fs(ctx, flags, io_ptr, &fs);
            if ((orig_retval == 0) && retval != 0) {
                if (fs)
                    ext2fs_close(fs);
                log_out(ctx, _("%s: %s while using the "
                           "backup blocks"),
                    ctx->program_name,
                    error_message(retval));
                log_out(ctx, _("%s: going back to original "
                           "superblock\n"),
                    ctx->program_name);
                ctx->superblock = orig_superblock;
                retval = try_open_fs(ctx, flags, io_ptr, &fs);
            }
        }
    }
    if (((retval == EXT2_ET_UNSUPP_FEATURE) ||
         (retval == EXT2_ET_RO_UNSUPP_FEATURE)) &&
        fs && fs->super) {
        sb = fs->super;
        features[0] = (sb->s_feature_compat &
                   ~EXT2_LIB_FEATURE_COMPAT_SUPP);
        features[1] = (sb->s_feature_incompat &
                   ~EXT2_LIB_FEATURE_INCOMPAT_SUPP);
        features[2] = (sb->s_feature_ro_compat &
                   ~EXT2_LIB_FEATURE_RO_COMPAT_SUPP);
        if (features[0] || features[1] || features[2])
            goto print_unsupp_features;
    }
failure:
    if (retval) {
        if (orig_retval)
            retval = orig_retval;
        com_err(ctx->program_name, retval, _("while trying to open %s"),
            ctx->filesystem_name);
        if (retval == EXT2_ET_REV_TOO_HIGH) {
            log_out(ctx, "%s",
                _("The filesystem revision is apparently "
                  "too high for this version of e2fsck.\n"
                  "(Or the filesystem superblock "
                  "is corrupt)\n\n"));
            fix_problem(ctx, PR_0_SB_CORRUPT, &pctx);
        } else if (retval == EXT2_ET_SHORT_READ)
            log_out(ctx, "%s",
                _("Could this be a zero-length partition?\n"));
        else if ((retval == EPERM) || (retval == EACCES))
            log_out(ctx, _("You must have %s access to the "
                       "filesystem or be root\n"),
                   (ctx->options & E2F_OPT_READONLY) ?
                   "r/o" : "r/w");
        else if (retval == ENXIO)
            log_out(ctx, "%s",
                _("Possibly non-existent or swap device?\n"));
        else if (retval == EBUSY)
            log_out(ctx, "%s", _("Filesystem mounted or opened "
                     "exclusively by another program?\n"));
        else if (retval == ENOENT)
            log_out(ctx, "%s",
                _("Possibly non-existent device?\n"));
#ifdef EROFS
        else if (retval == EROFS)
            log_out(ctx, "%s", _("Disk write-protected; use the "
                         "-n option to do a read-only\n"
                         "check of the device.\n"));
#endif
        else
            fix_problem(ctx, PR_0_SB_CORRUPT, &pctx);
        fatal_error(ctx, 0);
    }
    /*
     * We only update the master superblock because (a) paranoia;
     * we don't want to corrupt the backup superblocks, and (b) we
     * don't need to update the mount count and last checked
     * fields in the backup superblock (the kernel doesn't update
     * the backup superblocks anyway).  With newer versions of the
     * library this flag is set by ext2fs_open2(), but we set this
     * here just to be sure.  (No, we don't support e2fsck running
     * with some other libext2fs than the one that it was shipped
     * with, but just in case....)
     */
    fs->flags |= EXT2_FLAG_MASTER_SB_ONLY;

    if (!(ctx->flags & E2F_FLAG_GOT_DEVSIZE)) {
        __u32 blocksize = EXT2_BLOCK_SIZE(fs->super);
        int need_restart = 0;

        pctx.errcode = ext2fs_get_device_size2(ctx->filesystem_name,
                               blocksize,
                               &ctx->num_blocks);
        /*
         * The floppy driver refuses to allow anyone else to
         * open the device if has been opened with O_EXCL;
         * this is unlike other block device drivers in Linux.
         * To handle this, we close the filesystem and then
         * reopen the filesystem after we get the device size.
         */
        if (pctx.errcode == EBUSY) {
            ext2fs_close(fs);
            need_restart++;
            pctx.errcode =
                ext2fs_get_device_size2(ctx->filesystem_name,
                            blocksize,
                            &ctx->num_blocks);
        }
        if (pctx.errcode == EXT2_ET_UNIMPLEMENTED)
            ctx->num_blocks = 0;
        else if (pctx.errcode) {
            fix_problem(ctx, PR_0_GETSIZE_ERROR, &pctx);
            ctx->flags |= E2F_FLAG_ABORT;
            fatal_error(ctx, 0);
        }
        ctx->flags |= E2F_FLAG_GOT_DEVSIZE;
        if (need_restart)
            goto restart;
    }

    ctx->fs = fs;
    fs->priv_data = ctx;
    fs->now = ctx->now;
    sb = fs->super;

    if (sb->s_rev_level > E2FSCK_CURRENT_REV) {
        com_err(ctx->program_name, EXT2_ET_REV_TOO_HIGH,
            _("while trying to open %s"),
            ctx->filesystem_name);
    get_newer:
        fatal_error(ctx, _("Get a newer version of e2fsck!"));
    }

    /*
     * Set the device name, which is used whenever we print error
     * or informational messages to the user.
     */
    if (ctx->device_name == 0 &&
        (sb->s_volume_name[0] != 0)) {
        ctx->device_name = string_copy(ctx, sb->s_volume_name,
                           sizeof(sb->s_volume_name));
    }
    if (ctx->device_name == 0)
        ctx->device_name = string_copy(ctx, ctx->filesystem_name, 0);
    for (cp = ctx->device_name; *cp; cp++)
        if (isspace(*cp) || *cp == ':')
            *cp = '_';

    ehandler_init(fs->io);

    if ((fs->super->s_feature_incompat & EXT4_FEATURE_INCOMPAT_MMP) &&
        (flags & EXT2_FLAG_SKIP_MMP)) {
        if (e2fsck_check_mmp(fs, ctx))
            fatal_error(ctx, 0);

        /*
         * Restart in order to reopen fs but this time start mmp.
         */
        ext2fs_close(fs);
        ctx->fs = NULL;
        flags &= ~EXT2_FLAG_SKIP_MMP;
        goto restart;
    }

    if (ctx->logf)
        fprintf(ctx->logf, "Filesystem UUID: %s\n",
            e2p_uuid2str(sb->s_uuid));

    /*
     * Make sure the ext3 superblock fields are consistent.
     */
    retval = e2fsck_check_ext3_journal(ctx);
    if (retval) {
        com_err(ctx->program_name, retval,
            _("while checking ext3 journal for %s"),
            ctx->device_name);
        fatal_error(ctx, 0);
    }

    /*
     * Check to see if we need to do ext3-style recovery.  If so,
     * do it, and then restart the fsck.
     */
    if (sb->s_feature_incompat & EXT3_FEATURE_INCOMPAT_RECOVER) {
        if (ctx->options & E2F_OPT_READONLY) {
            log_out(ctx, "%s",
                _("Warning: skipping journal recovery because "
                  "doing a read-only filesystem check.\n"));
            io_channel_flush(ctx->fs->io);
        } else {
            if (ctx->flags & E2F_FLAG_RESTARTED) {
                /*
                 * Whoops, we attempted to run the
                 * journal twice.  This should never
                 * happen, unless the hardware or
                 * device driver is being bogus.
                 */
                com_err(ctx->program_name, 0,
                    _("unable to set superblock flags "
                      "on %s\n"), ctx->device_name);
                fatal_error(ctx, 0);
            }
            retval = e2fsck_run_ext3_journal(ctx);
            if (retval) {
                com_err(ctx->program_name, retval,
                _("while recovering ext3 journal of %s"),
                    ctx->device_name);
                fatal_error(ctx, 0);
            }
            ext2fs_close(ctx->fs);
            ctx->fs = 0;
            ctx->flags |= E2F_FLAG_RESTARTED;
            goto restart;
        }
    }

    /*
     * Check for compatibility with the feature sets.  We need to
     * be more stringent than ext2fs_open().
     */
    features[0] = sb->s_feature_compat & ~EXT2_LIB_FEATURE_COMPAT_SUPP;
    features[1] = sb->s_feature_incompat & ~EXT2_LIB_FEATURE_INCOMPAT_SUPP;
    features[2] = (sb->s_feature_ro_compat &
               ~EXT2_LIB_FEATURE_RO_COMPAT_SUPP);
print_unsupp_features:
    if (features[0] || features[1] || features[2]) {
        int    i, j;
        __u32    *mask = features, m;

        log_err(ctx, _("%s has unsupported feature(s):"),
            ctx->filesystem_name);

        for (i=0; i <3; i++,mask++) {
            for (j=0,m=1; j < 32; j++, m<<=1) {
                if (*mask & m)
                    log_err(ctx, " %s",
                        e2p_feature2string(i, m));
            }
        }
        log_err(ctx, "\n");
        goto get_newer;
    }
#ifdef ENABLE_COMPRESSION
    if (sb->s_feature_incompat & EXT2_FEATURE_INCOMPAT_COMPRESSION)
        log_err(ctx, _("%s: warning: compression support "
                   "is experimental.\n"),
            ctx->program_name);
#endif
#ifndef ENABLE_HTREE
    if (sb->s_feature_compat & EXT2_FEATURE_COMPAT_DIR_INDEX) {
        log_err(ctx, _("%s: e2fsck not compiled with HTREE support,\n\t"
              "but filesystem %s has HTREE directories.\n"),
            ctx->program_name, ctx->device_name);
        goto get_newer;
    }
#endif

    /*
     * If the user specified a specific superblock, presumably the
     * master superblock has been trashed.  So we mark the
     * superblock as dirty, so it can be written out.
     */
    if (ctx->superblock &&
        !(ctx->options & E2F_OPT_READONLY))
        ext2fs_mark_super_dirty(fs);

    /*
     * Calculate the number of filesystem blocks per pagesize.  If
     * fs->blocksize > page_size, set the number of blocks per
     * pagesize to 1 to avoid division by zero errors.
     */
#ifdef _SC_PAGESIZE
    sysval = sysconf(_SC_PAGESIZE);
    if (sysval > 0)
        sys_page_size = sysval;
#endif /* _SC_PAGESIZE */
    ctx->blocks_per_page = sys_page_size / fs->blocksize;
    if (ctx->blocks_per_page == 0)
        ctx->blocks_per_page = 1;

    if (ctx->superblock)
        set_latch_flags(PR_LATCH_RELOC, PRL_LATCHED, 0);
    ext2fs_mark_valid(fs);
    check_super_block(ctx);
    if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
        fatal_error(ctx, 0);
    check_if_skip(ctx);
    check_resize_inode(ctx);
    if (bad_blocks_file)
        read_bad_blocks_file(ctx, bad_blocks_file, replace_bad_blocks);
    else if (cflag)
        read_bad_blocks_file(ctx, 0, !keep_bad_blocks); /* Test disk */
    if (ctx->flags & E2F_FLAG_SIGNAL_MASK)
        fatal_error(ctx, 0);

    /*
     * Mark the system as valid, 'til proven otherwise
     */
    ext2fs_mark_valid(fs);

    retval = ext2fs_read_bb_inode(fs, &fs->badblocks);
    if (retval) {
        log_out(ctx, _("%s: %s while reading bad blocks inode\n"),
            ctx->program_name, error_message(retval));
        preenhalt(ctx);
        log_out(ctx, "%s", _("This doesn't bode well, "
                     "but we'll try to go on...\n"));
    }

    /*
     * Save the journal size in megabytes.
     * Try and use the journal size from the backup else let e2fsck
     * find the default journal size.
     */
    if (sb->s_jnl_backup_type == EXT3_JNL_BACKUP_BLOCKS)
        journal_size = (sb->s_jnl_blocks[15] << (32 - 20)) |
                   (sb->s_jnl_blocks[16] >> 20);
    else
        journal_size = -1;

    if (sb->s_feature_ro_compat & EXT4_FEATURE_RO_COMPAT_QUOTA) {
        /* Quotas were enabled. Do quota accounting during fsck. */
        if ((sb->s_usr_quota_inum && sb->s_grp_quota_inum) ||
            (!sb->s_usr_quota_inum && !sb->s_grp_quota_inum))
            qtype = -1;
        else
            qtype = sb->s_usr_quota_inum ? USRQUOTA : GRPQUOTA;

        quota_init_context(&ctx->qctx, ctx->fs, qtype);
    }

    run_result = e2fsck_run(ctx);
    e2fsck_clear_progbar(ctx);

    if (ctx->flags & E2F_FLAG_JOURNAL_INODE) {
        if (fix_problem(ctx, PR_6_RECREATE_JOURNAL, &pctx)) {
            if (journal_size < 1024)
                journal_size = ext2fs_default_journal_size(ext2fs_blocks_count(fs->super));
            if (journal_size < 0) {
                fs->super->s_feature_compat &=
                    ~EXT3_FEATURE_COMPAT_HAS_JOURNAL;
                fs->flags &= ~EXT2_FLAG_MASTER_SB_ONLY;
                log_out(ctx, "%s: Couldn't determine "
                    "journal size\n", ctx->program_name);
                goto no_journal;
            }
            log_out(ctx, _("Creating journal (%d blocks): "),
                   journal_size);
            fflush(stdout);
            retval = ext2fs_add_journal_inode(fs,
                              journal_size, 0);
            if (retval) {
                log_out(ctx, "%s: while trying to create "
                    "journal\n", error_message(retval));
                goto no_journal;
            }
            log_out(ctx, "%s", _(" Done.\n"));
            log_out(ctx, "%s",
                _("\n*** journal has been re-created - "
                  "filesystem is now ext3 again ***\n"));
        }
    }
no_journal:

    if (ctx->qctx) {
        int i, needs_writeout;
        for (i = 0; i < MAXQUOTAS; i++) {
            if (qtype != -1 && qtype != i)
                continue;
            needs_writeout = 0;
            pctx.num = i;
            retval = quota_compare_and_update(ctx->qctx, i,
                              &needs_writeout);
            if ((retval || needs_writeout) &&
                fix_problem(ctx, PR_6_UPDATE_QUOTAS, &pctx))
                quota_write_inode(ctx->qctx, i);
        }
        quota_release_context(&ctx->qctx);
    }

    if (run_result == E2F_FLAG_RESTART) {
        log_out(ctx, "%s",
            _("Restarting e2fsck from the beginning...\n"));
        retval = e2fsck_reset_context(ctx);
        if (retval) {
            com_err(ctx->program_name, retval, "%s",
                _("while resetting context"));
            fatal_error(ctx, 0);
        }
        ext2fs_close(fs);
        goto restart;
    }
    if (run_result & E2F_FLAG_CANCEL) {
        log_out(ctx, _("%s: e2fsck canceled.\n"), ctx->device_name ?
            ctx->device_name : ctx->filesystem_name);
        exit_value |= FSCK_CANCELED;
    }
    if (run_result & E2F_FLAG_ABORT)
        fatal_error(ctx, _("aborted"));
    if (check_backup_super_block(ctx)) {
        fs->flags &= ~EXT2_FLAG_MASTER_SB_ONLY;
        ext2fs_mark_super_dirty(fs);
    }

#ifdef MTRACE
    mtrace_print("Cleanup");
#endif
    if (ext2fs_test_changed(fs)) {
        exit_value |= FSCK_NONDESTRUCT;
        if (!(ctx->options & E2F_OPT_PREEN))
            log_out(ctx, _("\n%s: ***** FILE SYSTEM WAS "
                       "MODIFIED *****\n"),
                ctx->device_name);
        if (ctx->mount_flags & EXT2_MF_ISROOT) {
            log_out(ctx, _("%s: ***** REBOOT LINUX *****\n"),
                ctx->device_name);
            exit_value |= FSCK_REBOOT;
        }
    }
    if (!ext2fs_test_valid(fs) ||
        ((exit_value & FSCK_CANCELED) &&
         (sb->s_state & EXT2_ERROR_FS))) {
        log_out(ctx, _("\n%s: ********** WARNING: Filesystem still has "
                   "errors **********\n\n"), ctx->device_name);
        exit_value |= FSCK_UNCORRECTED;
        exit_value &= ~FSCK_NONDESTRUCT;
    }
    if (exit_value & FSCK_CANCELED) {
        int    allow_cancellation;

        profile_get_boolean(ctx->profile, "options",
                    "allow_cancellation", 0, 0,
                    &allow_cancellation);
        exit_value &= ~FSCK_NONDESTRUCT;
        if (allow_cancellation && ext2fs_test_valid(fs) &&
            (sb->s_state & EXT2_VALID_FS) &&
            !(sb->s_state & EXT2_ERROR_FS))
            exit_value = 0;
    } else {
        show_stats(ctx);
        if (!(ctx->options & E2F_OPT_READONLY)) {
            if (ext2fs_test_valid(fs)) {
                if (!(sb->s_state & EXT2_VALID_FS))
                    exit_value |= FSCK_NONDESTRUCT;
                sb->s_state = EXT2_VALID_FS;
            } else
                sb->s_state &= ~EXT2_VALID_FS;
            sb->s_mnt_count = 0;
            if (!(ctx->flags & E2F_FLAG_TIME_INSANE))
                sb->s_lastcheck = ctx->now;
            memset(((char *) sb) + EXT4_S_ERR_START, 0,
                   EXT4_S_ERR_LEN);
            ext2fs_mark_super_dirty(fs);
        }
    }

    if ((run_result & E2F_FLAG_CANCEL) == 0 &&
        sb->s_feature_ro_compat & EXT4_FEATURE_RO_COMPAT_GDT_CSUM &&
        !(ctx->options & E2F_OPT_READONLY)) {
        retval = ext2fs_set_gdt_csum(ctx->fs);
        if (retval) {
            com_err(ctx->program_name, retval, "%s",
                _("while setting block group checksum info"));
            fatal_error(ctx, 0);
        }
    }

    e2fsck_write_bitmaps(ctx);
    io_channel_flush(ctx->fs->io);
    print_resource_track(ctx, NULL, &ctx->global_rtrack, ctx->fs->io);

    ext2fs_close(fs);
    ctx->fs = NULL;
    free(ctx->journal_name);

    e2fsck_free_context(ctx);
    remove_error_table(&et_ext2_error_table);
    remove_error_table(&et_prof_error_table);
    return exit_value;
}
```