链接器涉及到的体系结构问题
================================================================================

链接器和加载器,以及编译器和汇编器,与体系结构的细节密切相关,这包括硬件体系结构和操作系统对
目标计算机在体系结构方面的约定。

硬件体系结构的两个方面影响到链接器: **程序寻址和指令格式**。链接器需要做的事情之一就是对
数据和指令中的地址及偏移量都要进行修改。两种情况下链接器都必须确保所做的修改符合计算机使用的寻址方式;
当修改指令时还需要进一步确保修改结果不能是无效指令。

应用程序二进制接口
--------------------------------------------------------------------------------

每个操作系统都会为运行在该系统下的应用程序提供应用程序二进制接口(Application Binary Interface)。
ABI 包含了应用程序在这个系统下运行时必须遵守的编程约定。ABI总是包含一系列的系统调用和使用这些
系统调用的方法,以及关于程序可以使用的内存地址和使用机器寄存器的规定。从一个应用程序的角度看,
ABI 既是系统架构的一部分也是硬件体系结构的重点,因此只要违反二者之一的条件约束就会导致程序出现严重错误。
在很多情况下,链接器为了遵守 ABI 的约定需要进行一些重要的工作。

例如,ABI 要求每个应用程序包含一个该程序中各例程使用的所有静态数据的地址表,链接器通常会通过收集所有
链接到程序中的模块的地址信息来创建这个表。ABI 经常会影响链接器的是对标准过程调用的定义.

内存地址
--------------------------------------------------------------------------------

计算机系统都有主存储器。主存总是表现为一块连续的存储空间,每一个存储位置都有一个数字地址。
这个地址从 0 开始,并逐渐增长为某个较大的数字(由地址中的位数决定)。

### 字节顺序和对齐

每个存储位置都是由固定数量的数位(bit)组成的。经过将近 50 年的历史,由 64 位到 1 位组成的计算机存储位置都被设计过,
但现在几乎所有产品化的计算机都使用 8 位(1字节)的地址。由于计算机处理的大多数数据,尤其是程序地址,都是大于8位的,
所以通过将相邻的字节合为一组,计算机同样可以很好的处理 16 位、32 位、64 位或 128 位的数据。

在某些计算机上:

* IBM 和 Motorola,多字节数据的第一个字节(数字地址最低)是高位字节(most significant byte);
* 在其它诸如 DEC 和 Intel 的机器上,第一个字节是低位字节(least significant byte).
沿用"格列佛游记"中的典故,将IBM/Motorola 的字节序策略称为big-endian,而DEC/Intel的字节序策略称为little-endian.

由两种方案的优缺点引起的激烈讨论已经持续了很多年了。由于在两台字节序相同的机器间移植程序要比不同字节序的机器要容易的多,
所以实际中对字节序选择的主要考虑来自于对旧系统的兼容。

新近的很多芯片设计可以支持任何一种字节序,这可以在芯片布线时进行选择,也可以在系统引导时通过编程选择,
甚至某些情况下可以针对每个应用程序进行不同选择。(在这些可切换的芯片上,被加载和存储指令处理的数据的
字节序会发生变化,但是被编码到指令中的常量的字节序是不变的,这是一些可以让链接器作者的工作变得很有趣的细节)

多字节数据通常会被对齐到一些“天生”的边界上。就是说,4 字节的数据必须对齐到4 字节的边界上,
2字节要对齐到2字节的边界上,并以此类推。另一种想法就是任何 N 字节数据的地址至少要有 log 2 (N)个低位为 0。

**注意**: 在某些系统上(Intel X86,DEC VAX,IBM 370/390),引用未对齐数据会付出性能降低的代价,
在另外一些系统上(多数 RISC 芯片),这会导致程序故障。即使在那些引用未对齐数据不会导致故障的系统上,
性能的损失也是非常大的,以至于值得我们花费精力来尽可能保持地址的对齐。

很多处理器同样要求程序指令的对齐。多数 RISC 芯片要求指令必须对齐在 4 字节的边界上。
每种体系结构都定义了一系列的寄存器,这是可以由程序指令直接引用的数量很少的固定长度高速存储区域。

各种体系结构的寄存器数量是变化的,从 x86 架构的 8 个到某些 RISC 设计的 32 个,
寄存器的容量几乎都是和程序地址的大小相同,就是说在一个 32 位地址的系统中寄存器是32位的,
而在具有 64 位地址的系统上,寄存器就是 64 位的了。

### 地址构成

当计算机程序执行时,会根据程序中的指令来读写内存。程序的指令本身也存储在内存中,但通常和程序的数据
位于内存中不同的部分。

指令在逻辑上是按照存储的顺序被执行的,但通过指定程序中新的地址来执行的跳转指令是例外
(有些体系结构会用名词“分支(branch)”来指代某些或者全部的跳转,但是我们在这里把它们都称为跳转)。

**注意**:
* 每个指令中引用的数据内存地址;
* 每个跳转指令引用的地址;
* 要被加载或存储的数据的地址;
* 指令要跳转到的地址等.
计算机们具有一系列的指令格式和地址构成需要链接器在重定位指令中的地址时予以处理。

尽管计算机设计者们在这些年中提出了无数不同而复杂的寻址策略,但现在大多数产品化的计算机都使用一套
类似的简单寻址策略(设计者发现很难设计出高速的复杂体系结构,而且编译器也很少能够充分利用复杂寻址
特性)。我们以三种架构为例:

* IBM 360/370/390(这里统称为 370)。尽管这是仍在使用中的最古老的架构之一,并在过去的 35 年中不断
增加新特性,但其相对简洁的设计仍然能够很好的工作,并且能够实现在可以与现代 RISC 性能相当的芯片中。

* SPARC V8 和 V9。一个流行的 RISC 架构,具有相当简单的寻址策略。V8 使用 32 位的寄存器和地址,
V9 扩充了 64 位的寄存器和地址。SPARC 的设计与其它诸如 MIPS和 Alpha 这样的 RISC 架构相似。

* Intel 386/486/Pentium(这里通称为 x86)。仍在使用的最无规律和无法理解的架构之一,但不可否认它是
最流行的。

### 指令格式

每种体系结构都有一些不同的指令格式。我们将只探讨与程序和数据寻址相关的格式细节,因为这些是影响
链接器的主要细节。

370在数据引用和跳转中使用相同的指令格式,SPARC使用不同的指令格式,而Intel的有些格式相同,有些格式不同。

每条指令都包含:

* 一个操作码: 它决定了指令做什么,
* 一个操作数: 操作数可以被编码到指令本身(立即操作数),或者放置在内存中。

**注意**:
内存中每个操作数的地址总要经过一些计算:

* 直接寻址: 有时地址包含在指令中;
* 寄存器间接寻址: 地址存储在某一个寄存器中或通过将指令中的一个常量加上寄存器中的内容计算得来;
* 基址寻址: 如果寄存器中的值是一个存储区域的地址,而指令中的常量是存储区域中想要访问的数据的偏移量;
* 索引寻址: 将基址寻址二者调换过来,并且寄存器中保存的是偏移量。
**基址寻址与索引寻址之间的区别不那么好定义,而且很多体系结构都将他们混在一起了**。

例如, 370有一种寻址模式会将两个寄存器和指令中的常量加在一起,并强制的将一个寄存器称作基址寄存器,
另一个为索引寄存器,虽然他们都是相同对待的。

还有其它更为复杂的地址计算方法也仍在使用中,但是由于它们不包含链接器需要调整的域,因此链接器的多数
组成部分都不需为此担心。一些体系结构使用固定长度的指令,而另一些使用变长指令。

所有的 SPARC 指令都是4字节长,并对齐到 4 字节边界。IBM 370 的指令可以是 2、4 或 6 个字节长,
指令的头一个字节的头 2 位确定了指令的长度和格式。Intel x86 的指令格式随时都可以是 1 到 14 个字节
长。这里的编码方式颇为复杂,部分是由于 x86 最初是为内存受限环境设计的紧凑指令编码,另外也是在
286、386 和后继芯片上的新加指令不得不被硬塞到已存在指令集未使用的位模式中。幸运的是,从链接器
作者的角度来看,链接器需要调整的地址和偏移量都是以字节为边界的,所以通常不需要考虑指令编码问题.

过程调用和可寻址性
--------------------------------------------------------------------------------

在最早的计算机中,内存很小,指令中的地址域足够容纳计算机任何一个内存位置的地址,现在我们称这种策略
为直接寻址。在上世纪 60 年代早期,可寻址内存已经变得相当大使得如果指令集中每个指令都包含整个地址
将占用太多仍然宝贵的内存。为了解决这个问题,计算机的架构师们在地址引用指令中部分或彻底的放弃了
直接寻址,使用索引和基址寄存器来提供寻址所需的大部分或全部地址位。这可以让指令短一些,但与之而来的
代价是编程更复杂了。

在没有采用直接寻址的体系结构中,包括 IBM 370 和 SPARC,程序在进行数据寻址时存在一个"自举"的问题:

一个例程要使用寄存器中的基地址来计算数据地址,但是将基址从内存中加载到寄存器中的标准方法是从存有
另一个基址的寄存器中寻址。

**自举问题就是如何在程序开始时将第一个基地址载入到寄存器中,随后再确保每一个例程都拥有它需要的基地址来寻址它要使用的数据。**

### 过程调用

每种 ABI 都通过将硬件定义的调用指令与内存、寄存器的使用约定组合起来定义了一个标准的过程调用序列。
硬件的调用指令保存了返回地址(调用执行后的指令地址)并跳转到目标过程。

在诸如 x86 这样具有硬件栈的体系结构中返回地址被压入栈中,而在其它体系结构中它会被保存在一个寄存器
里,如果必要软件要负责将寄存器中的值保存在内存中。具有栈的体系结构通常都会有一个硬件的返回指令将
返回地址推出栈并跳转到该地址,而其它体系结构则使用一个“跳转到寄存器中地址”的指令来返回。

在一个过程的内部,数据寻址可分为 4 类:

* 调用者可以向过程传递参数;
* 本地变量在过程中分配,并在过程返回前释放;
* 本地静态数据 保存在内存的固定位置中,并为该过程私有;
* 全局静态数据 保存在内存的固定位置中,并可被很多不同过程引用。

为每个过程调用分配的一块栈内存称为“栈框架(stack frame)”,可参考:

x86体系结构的c函数调用过程:

* https://github.com/leeminghao/doc-linux/blob/master/linker/CFunctionCall.md

arm体系结构的c函数调用过程:

* https://github.com/leeminghao/doc-linux/blob/master/linker/GccSsp.md

参数和本地变量通常在栈中分配空间,某一个寄存器可以作为栈指针,它可以基址寄存器来使用。

SPARC 和 x86 中使用了该策略的一种比较普遍的变体,在一个过程开始的时候,会从栈指针中加载专门的框架
指针或基址指针寄存器。这样就可以在栈中压入可变大小的对象,将栈指针寄存器中的值改变为难以预定的值,
当仍使过程的参数和本地变量们仍然位于相对于框架指针在整个过程执行中都不变的固定偏移量处。

如果假定栈是从高地址向低地址生长的,而框架指针指向返回地址保存在内存中的位置,那么参数就位于框架
指针较小的正偏移量处,本地变量在负偏移量处。可参考:

https://github.com/leeminghao/doc-linux/blob/master/linker/CFunctionCall.md

由于操作系统通常会在程序启动前为其初始化栈指针,所以程序只需要在将输入压栈或推栈时更新寄存器即可。

对于局部和全局静态数据,编译器可以为一个例程引用的所有静态变量创建一个指针表。如果某个寄存器存有
指向这个表的指针,那么例程可以通过使用表指针寄存器将对象在表中的指针读取出来,加载到另一个使用表
指针寄存器作为基址的寄存器中,并将第二个寄存器做为基址寄存器来寻址任何想要访问的静态目标。
因此,关键技巧是表的地址存入到第一个寄存器中。

在SPARC上,例程可以通过带有立即操作数的一系列指令来加载表地址,同时在SPARC或者370上例程可以通过
一系列子例程调用指令将程序计数器(保存当前指令地址的寄存器)加载到一个基址寄存器.

这种方法在对待库代码时会遇到问题, 一个更好的解决方法是**将提取表指针的工作交给例程的调用者,
因为调用者已经加载了自己的表指针,并可以从自己的表中获取被调用例程的表的指针。**

下图所示为一个典型的例程调用序列:
Rf 是框架指针,Rt 是表指针,Rx 是临时寄存器。
调用者将自己的表指针保存到自己的栈框架中,然后将被调用例程的地址和它的指针表地址载入到寄存器中,
再进行调用。被调用的例程可以通过 Rt 中的表指针找到它需要的所有数据,包括它随后要调用的例程的
地址和表指针。

理想的调用过程:
```
// 将参数压入堆栈
store Rt
xxx(Rf) ; save caller’s table pointer in caller’s stack frame
load Rx MMM(Rt) ; load address of called routine into temp register
load Rt NNN(Rt) ; load called routine’s table pointer
call (Rx) ; call routine at address in Rx
load Rt
xxx(Rf) ; restore caller’s table pointer
```

有一些优化方法经常是可能有用的, 很多情况下,在一个模块中的所有例程会共享一个指针表,这时模块内的
调用不需要改变表指针。

SPARC 的约定是整个模块共享一个由链接器创建的表,这样表指针寄存器可以在模块内调用时保持不变。
同一模块内的调用可以通过一个将被调用例程的偏移量编码到指令中的调用指令实现,这就不需要再将
被调用例程的地址加载到寄存器中了。

在所有这些优化中,同一模块中对某个例程的调用序列缩减为一个单独的调用指令。又回到地址自举的问题了,
这个表指针的链最初是怎么开始的呢?如果每一个例程都从前面例程中获取它的表指针,那么最初的例程从哪里
获得呢? 答案不是固定的,但是总会涉及到一些特殊代码。主例程的表可能存储在一个固定的位置,或初始指针
值被标注在可执行文件中这样操作系统可以在程序开始前加载它。无论使用的是什么技术,都是需要链接器
的帮助的。