目标文件
================================================================================

在前面我们大致了解了链接器以及加载器的基本工作:

https://github.com/leeminghao/doc-linux/blob/master/linker/LinkerAndLoader.md

以及C函数的调用方式:

https://github.com/leeminghao/doc-linux/blob/master/linker/CFunctionCall.md

我们了解到:

* 编译器和汇编器创建了目标文件(包含由源程序生成的二进制代码和数据);
* 链接器将多个目标文件合并成一个;
* 加载器读取这些目标文件并将它们加载到内存中(在一个集成编程环境中,当用户告诉它建立一个程序时,
  编译器、汇编器、链接器会在后台运行,但是它们确实是存在于“盖子”下面的)。

在接下来，我们将深入到目标文件格式和内容的细节之中。

在详细了解目标文件格式之前，我们可能需要先了解一下链接器可能涉及到的体系结构问题:

https://github.com/leeminghao/doc-linux/blob/master/linker/LinkerArch.md

目标文件中都有什么?
--------------------------------------------------------------------------------

一个目标文件包含五类信息:

* 头信息: 关于文件的整体信息,诸如代码大小,翻译成该目标文件的源文件名称,和创建日期等。

* 目标代码: 由编译器或汇编器产生的二进制指令和数据。

* 重定位信息: 目标代码中的一个位置列表,链接器在修改目标代码的地址时会对它进行调整。

* 符号: 该模块中定义的全局符号,以及从其它模块导入的或者由链接器定义的符号。

* 调试信息: 目标代码中与链接无关但会被调试器使用到的其它信息。包括源代码文件和行号信息,
  本地符号,被目标代码使用的数据结构描述信息(如 C 语言数据结构定义)。

**注意**:

并不是所有的目标文件格式都包含这几类信息,一个很有用的目标文件格式很少或不包含以上任何信息,都是可能的。

设计一个目标文件格式
--------------------------------------------------------------------------------

对一个目标文件格式的设计实际上是对目标文件所处的各种用途导致的折衷方案:

* 一个文件可能是可链接的,能够作为链接编辑器或链接加载器的输入;

* 它也可能是可执行的,可以加载到内存中作为一个程序运行;

* 或者是可加载的,作为库同程序一起被加载到内存中;

或者它是以上几种情况的组合, 某些格式只支持上面的一到两种用法,而另一些格式则支持所有的用法。

* 一个可链接文件还包含链接器处理目标代码时所需的扩展符号和重定位信息, 目标代码经常被划分为多个会被链接器区别对待的小逻辑段.

* 一个可执行程序中会包含目标代码(为了能让文件被映射到地址空间中它通常是页对齐的),但是可以不需要任何符号(除非它要进行运行时动态链接)以及重定位信息。

目标代码可以是一个单独的大段,或反映了硬件执行环境的一组小段(多数是只读或可读写的页)。根据系统运行
时环境细节的不同,一个可加载文件可以仅包含目标代码,或为了进行运行时链接还包含了完整的符号和重定位信息。

在应用中会存在某些冲突, 面向逻辑的可链接段分组策略很少能够与面向硬件的可执行段分组策略相匹配。
尤其是在一些较小的计算机上,链接器每次只会对可链接文件的一小片进行读写,但可执行程序会被整体的
加载到内存中。

这种区别在 MS-DOS 中尤为明显, 因为它的可链接 OMF 格式与可执行 EXE 格式是完全不同的。

这里我们将会涉及到一系列常用的格式,从最简单的开始,一直到最复杂的

空目标文件格式: MS-DOS 的.COM 文件
--------------------------------------------------------------------------------

碰到一个仅有可运行二进制代码而没有其它信息的能够使用的目标代码文件是可能的。
MS-DOS 的.COM 就是最有名的例子。一个.COM 文件中除了二进制代码外没有别的。

当操作系统运行一个.COM 文件时:

它只需将文件的内容加载到一块空闲内存中, 从偏移量 0x100 处开始执行(0-0xFF存放的是程序的命令行参数
和其它参数,称为程序段前缀 PSP), 将所有的x86 段寄存器设置为指向 PSP,将 SP(栈指针)寄存器指向该段的
末尾(由于栈是向下生长的),然后跳转到被加载程序的入口处。

x86 的分段架构使得这种文件格式可以工作。因为所有的 x86 程序地址都被解释为是相对于当前段基地址的,
所有的段寄存器都指向该段的基址,而程序总是以相对段位置为 0x100 的方式被加载。
因此, 对于可以放入单个段的程序而言,由于段相对地址可以在链接时确定而不需要再进行调整。
对于那些不能放入单一段的程序来说,对地址的调整工作是程序员的事情。而且确实存在一些程序
是在启动时读取某个段寄存器然后将它的值与保存在程序中的某个地方的段值相加。

代码区段: Unix a.out 文件
--------------------------------------------------------------------------------

具有硬件内存重定位部件的计算机系统(今天几乎所有的计算机都有)通常都会为新运行的程序创建一个具有
空地址空间的新进程,这种情况下程序就可以按照从某个固定地址开始的方式被链接,而不需要加载时的重定位。
UNIX 的 a.out 目标文件格式就是针对这种情况的。

最简单的情况下,一个 a.out 文件包含一个小文件头,后面接着是可执行代码(由于历史的原因被称为文本段),
然后是静态数据的初始值, PDP-11 只有 16 位寻址,将程序的地址空间限制为 64K。这个限制很快就变得太小
了,所以 PDP-11 产品线的后续型号为代码(称为指令空间 I)和数据(称为数据空间 D)提供了独立的地址空间,
这样一个程序可以拥有 64K 的代码空间和 64K 的数据空间。为了支持这个特性,编译器、汇编器、链接器都
被修改为可以创建两个段的目标文件(代码放入第一个段中,数据放入第二个段中,程序加载时先将第一个段载入
进程的 I 空间,再将第二个段载入进程的 D 空间)。

简化的a.out:

https://github.com/leeminghao/doc-linux/blob/master/linker/a.out.png

独立的 I 和 D 空间还有另一个性能上的优势:

由于一个程序不能修改自己的 I 空间,因此一个程序的多个实体可以共享一份程序代码的副本。
在诸如 UNIX 这样的分时系统上,shell(命令解释器)和网络服务进程具有多个副本是很普遍的,
共享程序代码可以节省相当可观的内存空间。

现在唯一通用的仍然为代码和数据进行单独寻址的计算机就是 286(或处于 16 位保护模式的 386)。

即使在地址空间巨大的现代计算机上,操作系统也可以通过虚拟内存来更有效的(相比于可读/写页的方式)处理只读代码页的共享,因此所有的现代加载器都支持它们。

这意味着链接器创建的格式中至少要标识出只读和可读写的段来。实际中,多数链接器支持的格式中都具有
多种类型的段,诸如只读数据,供后继链接操作使用的符号和重定位信息段,调试符号,和共享库信息(UNIX 的
惯例令人混淆的将文件区段`section'称为段`segment',所以我们在讨论 UNIX 的文件格式时也使用这个术语)

### a.out头部

a.out 的头部根据 UNIX 版本的不同而略有变化,但最典型的是 BSD UNIX 的版本,如下所示:

```
int a_magic;  // 幻数
int a_text;   // 文本段大小
int a_data;   // 初始化的数据段大小
int a_bss;    // 未初始化的数据段大小
int a_syms;   // 符号表大小
int a_entry;  // 入口点
int a_trsize; // 文本重定位段大小
int a_drsize; // 数据重定位段大小
```

* 幻数 a_magic 说明了当前可执行文件的类型。不同的幻数告诉操作系统的程序加载器以不同的方式将文件
  加载到内存中;

* 文本和数据段大小 a_text和 a_data 以字节为单位标识了头部后面的只读代码段和可读写数据段的大小。
  由于 UNIX 会自动将新分配的内存清零,因此初值无关紧要或者为 0 的数据不必在 a.out 文件中存储;

* 未初始化数据大小 a_bss 说明了在 a.out 文件中的可读写数据段后面逻辑上存在多少未初始化
  的数据(实际上是被初始化为 0);

* a_entry 域指明了程序的起始地址;

* a_syms,a_trsize 和 a_drsize 说明了在文件数据段后的符号表与重定位信息的大小。
  已经被链接好可以运行的程序中既不需要符号表也不需要重定位信息,所以除非链接器为了调试器加入
  符号信息,否则在可运行文件中这些域都是0.

### 与虚拟内存的交互

操作系统加载和启动一个简单的双段文件的过程非常简单,如下图所示:
加载一个 a.out 文件到一个进程中文件和段构成的图,箭头表明数据流向.

https://github.com/leeminghao/doc-linux/blob/master/linker/a.out_exec.png