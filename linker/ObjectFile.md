目标文件
================================================================================

在前面我们大致了解了链接器以及加载器的基本工作:

https://github.com/leeminghao/doc-linux/blob/master/linker/LinkerAndLoader.md

以及C函数的调用方式:

https://github.com/leeminghao/doc-linux/blob/master/linker/CFunctionCall.md

我们了解到:

* 编译器和汇编器创建了目标文件(包含由源程序生成的二进制代码和数据);
* 链接器将多个目标文件合并成一个;
* 加载器读取这些目标文件并将它们加载到内存中(在一个集成编程环境中,当用户告诉它建立一个程序时,
  编译器、汇编器、链接器会在后台运行,但是它们确实是存在于“盖子”下面的)。

在接下来，我们将深入到目标文件格式和内容的细节之中。

目标文件中都有什么?
--------------------------------------------------------------------------------

一个目标文件包含五类信息:

* 头信息: 关于文件的整体信息,诸如代码大小,翻译成该目标文件的源文件名称,和创建日期等。

* 目标代码: 由编译器或汇编器产生的二进制指令和数据。

* 重定位信息: 目标代码中的一个位置列表,链接器在修改目标代码的地址时会对它进行调整。

* 符号: 该模块中定义的全局符号,以及从其它模块导入的或者由链接器定义的符号。

* 调试信息: 目标代码中与链接无关但会被调试器使用到的其它信息。包括源代码文件和行号信息,
  本地符号,被目标代码使用的数据结构描述信息(如 C 语言数据结构定义)。

**注意**:

并不是所有的目标文件格式都包含这几类信息,一个很有用的目标文件格式很少或不包含以上任何信息,都是可能的。

设计一个目标文件格式
--------------------------------------------------------------------------------

对一个目标文件格式的设计实际上是对目标文件所处的各种用途导致的折衷方案:

* 一个文件可能是可链接的,能够作为链接编辑器或链接加载器的输入;

* 它也可能是可执行的,可以加载到内存中作为一个程序运行;

* 或者是可加载的,作为库同程序一起被加载到内存中;

或者它是以上几种情况的组合, 某些格式只支持上面的一到两种用法,而另一些格式则支持所有的用法。

* 一个可链接文件还包含链接器处理目标代码时所需的扩展符号和重定位信息, 目标代码经常被划分为多个会被链接器区别对待的小逻辑段.

* 一个可执行程序中会包含目标代码(为了能让文件被映射到地址空间中它通常是页对齐的),但是可以不需要任何符号(除非它要进行运行时动态链接)以及重定位信息。

目标代码可以是一个单独的大段,或反映了硬件执行环境的一组小段(多数是只读或可读写的页)。根据系统运行
时环境细节的不同,一个可加载文件可以仅包含目标代码,或为了进行运行时链接还包含了完整的符号和重定位信息。

在应用中会存在某些冲突, 面向逻辑的可链接段分组策略很少能够与面向硬件的可执行段分组策略相匹配。
尤其是在一些较小的计算机上,链接器每次只会对可链接文件的一小片进行读写,但可执行程序会被整体的
加载到内存中。

这种区别在 MS-DOS 中尤为明显, 因为它的可链接 OMF 格式与可执行 EXE 格式是完全不同的。

这里我们将会涉及到一系列常用的格式,从最简单的开始,一直到最复杂的

空目标文件格式: MS-DOS 的.COM 文件
--------------------------------------------------------------------------------

碰到一个仅有可运行二进制代码而没有其它信息的能够使用的目标代码文件是可能的。
MS-DOS 的.COM 就是最有名的例子。一个.COM 文件中除了二进制代码外没有别的。

当操作系统运行一个.COM 文件时:

它只需将文件的内容加载到一块空闲内存中, 从偏移量 0x100 处开始执行(0-0xFF存放的是程序的命令行参数
和其它参数,称为程序段前缀 PSP), 将所有的x86 段寄存器设置为指向 PSP,将 SP(栈指针)寄存器指向该段的
末尾(由于栈是向下生长的),然后跳转到被加载程序的入口处。

x86 的分段架构使得这种文件格式可以工作。因为所有的 x86 程序地址都被解释为是相对于当前段基地址的,
所有的段寄存器都指向该段的基址,而程序总是以相对段位置为 0x100 的方式被加载。
因此, 对于可以放入单个段的程序而言,由于段相对地址可以在链接时确定而不需要再进行调整。
对于那些不能放入单一段的程序来说,对地址的调整工作是程序员的事情。而且确实存在一些程序
是在启动时读取某个段寄存器然后将它的值与保存在程序中的某个地方的段值相加。

代码区段: Unix a.out 文件
--------------------------------------------------------------------------------

具有硬件内存重定位部件的计算机系统(今天几乎所有的计算机都有)通常都会为新运行的程序创建一个具有
空地址空间的新进程,这种情况下程序就可以按照从某个固定地址开始的方式被链接,而不需要加载时的重定位。
UNIX 的 a.out 目标文件格式就是针对这种情况的。

最简单的情况下,一个 a.out 文件包含一个小文件头,后面接着是可执行代码(由于历史的原因被称为文本段),
然后是静态数据的初始值, PDP-11 只有 16 位寻址,将程序的地址空间限制为 64K。这个限制很快就变得太小
了,所以 PDP-11 产品线的后续型号为代码(称为指令空间 I)和数据(称为数据空间 D)提供了独立的地址空间,
这样一个程序可以拥有 64K 的代码空间和 64K 的数据空间。为了支持这个特性,编译器、汇编器、链接器都
被修改为可以创建两个段的目标文件(代码放入第一个段中,数据放入第二个段中,程序加载时先将第一个段载入
进程的 I 空间,再将第二个段载入进程的 D 空间)。
