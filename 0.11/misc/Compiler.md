Linux 0.11内核使用的编译工具
================================================================================

语言编译过程就是把人类能理解的高级语言转换成计算机硬件能理解和执行的二进制机器指令的过程。
这种转换过程通常会产生一些效率不是很高的代码，所以对一些运行效率要求高或性能影响较大的部分代码
通常就会直接使用汇编语言来编写，或者对高级语言编译产生的汇编程序再进行人工修改优化处理。

Linux 0.11主要使用的编译器如下所示:

* 一种是能产生16位代码的as86汇编器，使用配套的ld86链接器；
* 另一种是GNU的汇编器gas（as），使用GNU ld链接器来链接产生的目标文件。
* 编译c语言的编译工具gcc

as86和ld86
--------------------------------------------------------------------------------

as86和ld86是由MINIX-386的主要开发者之一Bruce Evans编写的Intel 8086、80386汇编编译程序和链接程序。
在刚开始开发Linux内核时Linus就已经把它移植到了Linux系统上。它虽然可以为80386处理器编制32位代码，
但是Linux系统仅用它来创建:
* 16位的启动引导扇区程序boot/bootsect.s
* 实模式下初始设置程序boot/setup.s的二进制执行代码。

该编译器快速小巧，并具有一些GNU gas没有的特性，例如宏以及更多的错误检测手段。
不过该编译器的语法与GNU as汇编编译器的语法不兼容，而更近似于微软的MASM、Borland公司的Turbo ASM和NASM等汇编器的语法。
这些汇编器都使用了Intel的汇编语言语法（如操作数的次序与GNU as的相反等）。

as86的语法是基于MINIX系统的汇编语言语法，而MINIX系统的汇编语法则是基于PC/IX系统的汇编器语法。
PC/IX是很早以前在Intel 8086 CPU上运行的一个类UNIX操作系统，Tanenbaum就是在PC/IX系统上进行MINIX系统开发工作的。

Bruce Evans是MINIX操作系统32位版本的主要修改编制者之一，他与Linux的创始人Linus Torvalds是好友。
在Linux内核开发初期，Linus从Bruce Evans那里学到了不少有关类UNIX操作系统的知识。
MINIX操作系统的不足之处也是两个好朋友探讨得出的结果。MINIX的这些缺点正是激发Linus
在Intel 80386体系结构上开发一个全新概念操作系统的主要动力之一。
Linus曾经说过："Bruce是我的英雄"，因此我们可以说Linux操作系统的诞生与Bruce Evans也有着密切的关系。

### as86和ld86的使用方法和选项如下

##### as86的使用方法和选项：

```
as [-03agjuw] [-b [bin]] [-lm [list]]
[-n name] [-o objfile] [-s sym] srcfile
默认设置 (除了以下默认值以外，其他选项默认为关闭或无；
若没有明确说明a标志，则不会有输出):

-3   使用80386的32位输出；
list 在标准输出上显示；
name  源文件的基本名称（即不包括"."后的扩展名）；
各选项含义：
-0  使用16bit代码段；
-3  使用32bit代码段；
-a  开启与GNU as、ld的部分兼容性选项；
-b  产生二进制文件，后面可以跟文件名；
-g  在目标文件中仅存入全局符号；
-j  使所有跳转语句均为长跳转；
-l  产生列表文件，后面可以跟随列表文件名；
-m  在列表中扩展宏定义；
-n  后面跟随模块名称（取代源文件名称放入目标文件中）；
-o  产生目标文件，后跟目标文件名（objfile）；
-s  产生符号文件，后跟符号文件名；
-u  将未定义符号作为输入的未指定段的符号；
-w  不显示警告信息；
```

##### ld86的使用方法语法和选项如下:

```
对于生成Minix a.out格式的版本：
ld [-03Mims[-]]  [-T textaddr] [-llib_extension] [-o outfile] infile...

对于生成GNU-Minix的a.out格式的版本：
ld [-03Mimrs[-]] [-T textaddr] [-llib_extension] [-o outfile] infile...

默认设置(除了以下默认值以外，其他选项默认为关闭或无):
-03  32位输出；
outfile  a.out格式输出；
-0  产生具有16bit魔数的头结构，并且对-lx选项使用i86子目录；
-3  产生具有32bit魔数的头结构，并且对-lx选项使用i386子目录；
-M  在标准输出设备上显示已链接的符号；
-T  后面跟随正文基地址 (使用适合于strtoul的格式)；
-i  分离的指令与数据段（I&D）输出；
-lx 将库/local/lib/subdir/libx.a加入链接的文件列表中；
-m  在标准输出设备上显示已链接的模块；
-o  指定输出文件名，后跟输出文件名；
-r  产生适合于进一步重定位的输出；
-s  在目标文件中删除所有符号。
```

as与ld
--------------------------------------------------------------------------------

### 简介

上面介绍的as86汇编器仅用于编译内核中的boot/bootsect.S引导扇区程序和实模式下的设置程序boot/setup.s。
内核中其余所有汇编语言程序（包括C语言产生的汇编程序）均使用gas来编译，并与C语言程序编译产生的模块链接。
本节以80x86 CPU硬件平台为基础介绍Linux内核中使用汇编程序语法和GNU as汇编器（简称as汇编器）的使用方法。
我们首先介绍as汇编语言程序的语法，然后给出常用汇编伪指令（指示符）的含义和使用方法。

由于操作系统许多关键代码要求有很高的执行速度和效率，因此在一个操作系统源代码中通常就会包含大约10%的
起关键作用的汇编语言代码。Linux操作系统也不例外，它的32位初始化代码、所有中断和异常处理过程接口程序
以及很多宏定义都使用了as汇编语言程序或扩展的嵌入汇编语句。是否能够理解这些汇编语言程序的功能也就无疑
成为理解一个操作系统具体实现的关键之一。

在编译C语言程序时，GNU gcc编译器会首先输出一个作为中间结果的as汇编语言文件，然后gcc会调用as汇编器把这个
临时汇编语言程序编译成目标文件。即实际上as汇编器最初是专门用于汇编gcc产生的中间汇编语言程序的，
并非作为一个独立的汇编器使用。因此，as汇编器也支持很多C语言特性，这包括字符、数字和常数表示方法以及表达式形式等方面。

GNU as汇编器最初是仿照BSD 4.2的汇编器进行开发的。现在的as汇编器能够配置成产生很多不同格式的目标文件。
虽然编制的as汇编语言程序与具体采用或生成什么格式的目标文件关系不大，但是在下面介绍中若涉及目标文件格式时，
我们将围绕Linux 0.11系统采用的a.out目标文件格式进行说明。

### 编译as汇编语言程序

使用as汇编器编译一个as汇编语言程序的基本命令行格式如下：

```
as [ 选项 ] [ -o objfile ] [ srcfile.s ...]
其中，objfile是as编译输出的目标文件名；srcfile.s是as的输入汇编语言程序名。
```

如果没有使用输出文件名，那么as会编译输出名称为a.out的默认目标文件。在as程序名之后，命令行上可包含编译选项和文件名。
所有选项可随意放置，但是文件名的放置次序同编译结果密切相关。

一个程序的源程序可以放置在一个或多个文件中，程序的源代码无论怎样分割或放置在几个文件中
都不会改变程序的语义。程序的源代码是所有这些文件按次序的组合结果。每次运行as编译器，
它只编译一个源程序。但一个源程序可由多个文本文件组成（终端的标准输入也是一个文件）。

我们可以在as命令行上给出零个或多个输入文件名。as将会按从左到右的顺序读取这些输入文件的内容。
在命令行上任何位置处的参数若没有特定含义的话，将会被作为一个输入文件名看待。如果在命令行上
没有给出任何文件名，那么as将试图从终端或控制台标准输入中读取输入文件内容。在这种情况下，
若已没有内容要输入时就需要手工键入Ctrl-D组合键来告知as汇编器。
若想在命令行上明确指出把标准输入作为输入文件，那么就需要使用参数" "。

as的输出文件是输入的汇编语言程序编译生成的二进制数据文件，即目标文件。
除非我们使用选项"-o"指定输出文件的名称，否则as将产生名为a.out的输出文件。
目标文件主要用于作为链接器ld的输入文件。
目标文件中包含已汇编过的程序代码、协助ld产生可执行程序的信息，可能还包含调试符号信息。

### 区与重定位

##### 基本概念

区(Section)(也称为段、节或部分)用于表示一个地址范围，操作系统将会以相同的方式对待和处理在该地址范围中的数据信息。
例如，可以有一个"只读"的区，只能从该区中读取数据而不能写入。
区的概念主要用来表示编译器生成的目标文件（或可执行程序）中不同的信息区域，例如目标文件中的正文区或数据区。
若要正确理解和编制一个as汇编语言程序，我们就需要了解as产生的输出目标文件的格式安排。

链接器ld会把输入的目标文件中的内容按照一定规律组合生成一个可执行程序。**当as汇编器输出一个目标文件时，
该目标文件中的代码被默认设置成从地址0开始。此后ld将会在链接过程中为不同目标文件中的各个部分分配不同的最终地址位置。**
ld会把程序中的字节块移动到程序运行时的地址处。这些块是作为固定单元进行移动的。它们的长度以及字节次序都不会被改变。
这样的固定单元就被称做区（或段、部分）。
而为区分配运行时刻的地址的操作就被称为**重定位（Relocation）**操作，其中包括调整目标文件中记录的地址，
从而让它们对应到恰当的运行时刻地址上。

##### text,data,bss

as汇编器输出产生的目标文件中至少具有3个区:

* 正文（text）;
* 数据（data）;
* bss区。

每个区都可能是空的, 如果没有使用汇编命令把输出放置在.text或.data区中，这些区会仍然存在，但内容是空的。
在一个目标文件中，其text区从地址０开始，随后是data区，再后面是bss区。

当一个区被重定位时，为了让链接器ld知道哪些数据会发生变化以及如何修改这些数据，
as汇编器也会往目标文件中写入所需要的重定位信息。

为了执行重定位操作，在每次涉及目标文件中的一个地址时，ld必须知道：

* 目标文件中对一个地址的引用是从什么地方算起的？
* 该引用的字节长度是多少？
* 该地址引用的是哪个区？（地址）-（区的开始地址）的值等于多少？
* 对地址的引用与指令计数器PC相关吗？

实际上，as使用的所有地址都可表示为: （区）+（区中偏移）。
另外，as计算的大多数表达式都有这种与区相关的特性。
在下面说明中，我们使用记号"{secname N}"来表示区secname中偏移N。

##### absolute

除了text、data和bss区，我们还需要了解绝对地址区（absolute区）。
当链接器把各个目标文件组合在一起时，absolute区中的地址将始终不变。
例如，ld会把地址{absolute 0}"重定位"到运行时刻地址0处。尽管链接器
在链接后决不会把两个目标文件中的data区安排成重叠地址处，但是目标文件中的absolute区必会重叠而覆盖。

##### undefined区

另外，还有一种名为"未定义的"区（Undefined Section）。
在汇编时不能确定所在区的任何地址都被设置成{undefined U}，其中U将会在以后填上。
因为数值总是有定义的，所以出现未定义地址的唯一途径仅涉及未定义的符号。
对一个称为公共块（Common Block）的引用就是这样一种符号: 在汇编时它的值未知，因此它在undefined区中。

类似地，区名也用于描述已链接程序中区的组, 链接器ld会把程序所有目标文件中的text区放在相邻的地址处。
我们习惯上所说的程序的text区实际上是指其所有目标文件text区组合构成的整个地址区域。
对程序中data和bss区的理解也同样如此。

### ld链接器所涉及的区

链接器ld只涉及如下4类区：

* text区、data区: 这两个区用于保存程序, as和ld会分别独立而同等地对待它们。
对其中text区的描述也同样适合于data区, 然而当程序在运行时，通常text区是不会改变的。
text区通常会被进程共享，其中含有指令代码和常数等内容。程序运行时data区的内容通常是会变化的.

* bss区: 在程序开始运行时这个区中含有0值字节。该区用于存放未初始化的变量或作为公共变量存储空间。
虽然程序每个目标文件bss区的长度信息很重要，但是由于该区中存放的是0值字节，因此无须在目标文件中保存bss区。
设置bss区的目的就是为了从目标文件中明确地排除0值字节。

* absolute区: 该区的地址0总是"重定位"到运行时刻地址0处。如果你不想让ld在重定位操作时改变你所引用的地址，
那么就使用这个区。从这种观点来看，我们可以把绝对地址称做"不可重定位的"，即在重定位操作期间它们不会改变。

* undefined区: 对不在先前所述各个区中对象的地址引用都属于本区。

##### Example

下面是3个理想化的可重定位区的例子:
这个例子使用传统的区名称：.text和.data。其中水平轴表示内存地址。

https://github.com/leeminghao/doc-linux/blob/master/0.11/misc/ld_process.jpg

##### 子区

汇编取得的字节数据通常位于text或data区中。有时候在汇编源程序某个区中可能分布着一些不相邻的数据组，
但是你可能会想让它们在汇编后聚集在一起存放。as汇编器允许你利用子区（Subsection）来达到这个目的。
在每个区中，可以有编号为0～8192的子区存在。编制在同一个子区中的对象会在目标文件中与该子区中其他对象放在一起。
例如，编译器可能想把常数存放在text区中，但是不想让这些常数散布在被汇编的整个程序中。
在这种情况下，编译器就可以在每个会输出的代码区之前使用.text 0子区，并且在每组会输出的常数之前使用.text 1子区。

使用子区是可选的, 如果没有使用子区，那么所有对象都会被放在子区0中。
子区会以其从小到大的编号顺序出现在目标文件中，但是目标文件中并不包含表示子区的任何信息。
处理目标文件的ld以及其他程序并不会看到子区的踪迹，它们只会看到由所有text子区组成的
text区和由所有data子区组成的data区。
为了指定随后的语句被汇编到哪个子区中，可在".text表达式"或".data表达式"中使用数值参数。
表达式结果应该是绝对值,如果只指定了.text，那么就会默认使用.text 0。同样地，.data表示使用.data 0。

每个区都有一个位置计数器（Location Counter），它会对每个汇编进该区的字节进行计数。
由于子区是仅供as汇编器使用方便而设置的，因此并不存在子区计数器。
虽然没有什么直接操作一个位置计数器的方法，但是汇编命令.align可以改变其值，
并且任何标号定义都会取用位置计数器的当前值。正在执行语句汇编处理的区的位置计数器被称为当前活动计数器。

##### bss区

bss区用于存储局部公共变量，你可以在bss区中分配空间，但是在程序运行之前不能在其中放置数据。
因为当程序刚开始执行时，bss区中所有字节内容都将被清零。

.lcomm汇编命令用于在bss区中定义一个符号；
.comm可用于在bss区中声明一个公共符号。

### 符号

在程序编译和链接过程中，符号（Symbol）是一个比较重要的概念。
程序员使用符号来命名对象，链接器使用符号进行链接操作，而调试器利用符号进行调试。

标号（Label）是后面紧随一个冒号的符号。此时该符号代表活动位置计数器的当前值，
并且可作为指令的操作数使用。我们可以使用等号"="给一个符号赋予任意数值。

符号名以一个字母或"."， "_"字符之一开始。局部符号用于协助编译器和程序员临时使用名称。
在一个程序中共有10个局部符号名（"0"～"9"）可供重复使用。

为了定义一个局部符号，只要写出形如"N:"的标号（其中N代表任何数字）。
* 若是引用前面最近定义的这个符号，需要写成"Nb"；
* 若需引用下一个定义的局部标号，则需要写成"Nf"。
其中"b"意思是向后（backwards），"f"表示向前（Forwards）。
局部标号在使用方面没有限制，但是在任何时候我们只能向前/向后引用最远10个局部标号。

##### 特殊点符号

特殊符号"."表示as汇编的当前地址。因此表达式"mylab: .long ."就会把mylab定义为包含它自己所处的地址值。
给"."赋值就如同汇编命令".org"的作用。因此表达式".=.+4"与".space 4"完全相同。

##### 符号属性

除了名字以外，每个符号都有"值"和"类型"属性。根据输出的格式不同，符号也可以具有辅助属性。
如果不定义就使用一个符号，as就会假设其所有属性均为0。这指示该符号是一个外部定义的符号。

符号的值通常是32位的。对于标出text、data、bss或absolute区中一个位置的符号，
其值是从区开始到标号处的地址值。对于text、data和bss区，一个符号的值通常会
在链接过程中由于ld改变区的基地址而变化，absolute区中符号的值不会改变。这也是为何称它们是绝对符号的原因。

ld会对未定义符号的值进行特殊处理。如果未定义符号的值是0，则表示该符号在本汇编源程序中没有定义，
ld会尝试根据其他链接的文件来确定它的值。在程序使用了一个符号但没有对符号进行定义，就会产生这样的符号。
若未定义符号的值不为0，那么该符号值就表示是.comm公共声明的需要保留的公共存储空间字节长度。
符号指向该存储空间的第一个地址处。

符号的类型属性含有用于链接器和调试器的重定位信息、指示符号是外部的标志以及一些其他可选信息。
对于a.out格式的目标文件，符号的类型属性存放在一个8位字段中（n_type字节）。

有关编译的例子如下所示：

https://github.com/leeminghao/doc-linux/blob/master/0.11/sources/linux-0.00-050613/README.md