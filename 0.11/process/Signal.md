信号量机制
================================================================================

实例
--------------------------------------------------------------------------------

path: samples/samples.h
```
#include <signal.h>

static inline void sig_usr(int signo)
{
    if (signo == SIGUSR1) {
        printf("received SIGUSR1\n");
    } else {
        printf("received %d\n", signo);
    }
    _exit(0);
}

static inline __attribute__((always_inline)) int test_signal(void)
{
    pid_t pid;

    if ((pid = fork()) < 0) {
        return -1;
    } else if (pid == 0) {
        signal(SIGUSR1, sig_usr);
        for (;;)
            pause();
        return 0;
    } else {
        return kill(2, SIGUSR1);
    }
}
```

系统需要具备以下三个功能，以支持信号机制。

#### 系统要支持进程对信号的发送和接收系统:

在每个进程task_struct中都设置了用以接收信号的数据成员signal(信号位图)，每个进程接收到的信号
就“按位”存储在这个数据结构中。系统支持两种方式给进程发送信号：
* 一种方式是一个进程通过调用特定的库函数给另一个进程发送信号；
* 另一种方式是用户通过键盘输入信息产生键盘中断后，中断服务程序给进程发送信号。
这两种方式的信号发送原理是相同的，都是通过设置信号位图(signal)上的信号位来实现的。

#### 系统要能够及时检测到进程接收到的信号

系统通过两种方式来检测进程是否接收到信号：
* 一种方式是在系统调用返回之前检测当前进程是否接收到信号；
* 另一种方式是时钟中断产生后，其中断服务程序执行结束之前，检测当前进程是否接收到信号。
这两种信号检测方式大体类似。

#### 系统要支持进程对信号进行处理

系统要能够保证，当用户进程不需要处理信号时，信号处理函数完全不参与用户进程的执行；
当用户进程需要处理信号时，进程的程序将暂时停止执行，转而去执行信号处理函数，待信号
处理函数执行完毕后，进程程序将从“暂停的现场处”继续执行。

信号的使用
--------------------------------------------------------------------------------

在上述实例中，调用signal函数的进程(进程1的子进程)开始执行，要为接收信号做准备，具体表现为，
指定对哪种信号进行什么样的处理。用户程序是通过调用signal()函数来实现这个绑定的。这个函数是
库函数，它执行后会产生软中断int 0x80，并映射到sys_signal()这个系统调用函数去执行。sys_signal()
函数的功能是将用户自定义的信号处理函数sig_usr()与进程绑定。这意味着，只要进程接收到SIGUSR1信号，
就调用sig_usr函数来处理该信号，绑定工作就是通过该函数来完成的。进入sys_signal()函数后，系统先要
在绑定之前检测用户指定的信号是否符合规定。由于Linux 0.11中只能默认处理32种信号，而且默认忽略
SIGKILL这个信号，所以只要用户给出的信号不符合这些要求，系统将不能处理。执行代码如下：