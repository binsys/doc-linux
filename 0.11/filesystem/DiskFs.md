Linux 0.11 安装硬盘文件系统
================================================================================

概述
--------------------------------------------------------------------------------

#### MINIX文件系统:

MINIX文件系统不过是在用户空间中运行的一个大型C程序,读写文件时,用户进程向文件系统发送一条消息,文件系统进行相应处理后,返回结果.
实际上,MINIX文件系统可以看成是和调用进程在同一台主机上运行的网络文件服务程序.
文件系统的结构基本上与内存管理器和所有的I/O任务一样.文件系统的主循环程序不断地等待消息.当收到消息后,它首先提取消息的类型,
然后以其为索引查找文件系统中处理各类消息的过程指针表.随后调用相应过程,进行处理后,返回状态值.文件系统再把回答消息发送给调用进程,
然后回到循环的开始,等待下一条消息的到来。

MINIX文件系统是一个逻辑的, 自包含的实体. 它含有i-节点, 目录和数据块。MINIX文件系统可以存储在任何块设备中,
例如软盘或一个硬盘分区。MINIX的文件系统都有相同的布局: 如下所示是一个128个i-节点和1K块的360K软盘的布局.
更大的系统,或者是那些有不同的i-节点数和块大小的系统,也同样由这6部分顺序组成,但是各部分之间的相对大小可
能不一样:

```
{引导块(1)}{超级块(1)}{i节点位图块(1)}{逻辑块位图(1)}{i节点(n)}{数据块(n)}
```

###### 引导块:

每个文件系统都以引导块开始,引导块中包含有可执行代码.启动计算机时,硬件从引导设备将引导块读入内存,
转而执行其代码.引导块代码开始操作系统本身的加载过程。一旦系统启动之后,引导块不再使用.并非每个
磁盘驱动器均可用作引导设备,但是为了保持结构的一致,每个块设备都为引导块代码保留一块.这种方法最多
不过浪费了一个块. 为防止硬件从非启动设备上启动,在将可执行代码写入引导设备的引导块中时,在引导块的已
知位置处写入魔数。从一个设备上启动时,硬件(实际上是BIOS代码)首先检测魔数是否存在。若不存在,则拒绝把
引导块载入内存,这样可以防止把垃圾用作引导程序。

###### 超级块:

超级块(super-block)中含有文件系统的布局信息,它的主要功能是给出文件系统不同部分的大小.如果给定块大小和
i-节点数,我们很容易算出i-节点位图的大小和存放i-节点所需的块数。例如: 1K的块,每个位图块有1K字节(8K位),
可以记录8192个i-节点的状态(实际上第一块只能处理8191个i-节点,因为0号i-节点并不存在,但我们在位图中也为它保留一位).
10000个i-节点, 要用到两个位图块.每个i-节点占64字节,1K的块中可以有16个i-节点。如果有128个可用的i-节点,则需要8个磁盘块来存放。

磁盘存储区可以以区段为单位进行分配,而每个区段可以包含1、 2、4、 8个,或一般情况下,2n个磁盘块.区段位图按区段,
而不是块来记录空闲存储区。MINIX用到的所有标准软盘中,区段大小和块大小是一样的(均为1K),因此在这些设备上,
可以近似把区段看成是块。

可以注意到: 每个区段包含的块数并没有存放在超级块中,我们并不需要这一数据.我们存放的是底为2, 区段数除以块数
所得值的对数。根据它,可以知道从区段转换成块或者从块转换成区段要移位的次数. 例如,每个区段中含有8个块,log2^8=3,
因此要找到包含第128块的区段,我们可以把128右移3位,得到16.区段位图中只包含数据区段(即位图和i-节点用到的块并不在该位图中)。
第一个数据区段在位图中用区段1表示,同i-节点位图一样,区段位图中第0位也未使用,因此第一个区段位图块只能映射到8191个区段,
以后的每块可以映射到8192个区段.考察一下新格式化磁盘的位图,可以发现i-节点和区段位图中均有2位为1。一位是不存在的0号i-节点和0号区段,
而另一位是设备根目录使用的i-节点和区段,在文件系统创建时,根目录自动存在.

我们还可以注意到: 超级块中的信息冗余. 由于我们有1K空间可用于存放超级块的信息,因此我们可以事先按不同的形式算出所需的信息,
而不必在使用时重新计算. 例如,磁盘上的第一个数据区段的区段号,可以从块大小,区段大小,i-节点数以及区段数计算得到. 但是,
直接把它存放在超级块中要方便得多. 超级块中的剩下部分总归是要浪费的,我们还不如用它来存储一些有用的数据。

在MINIX启动时, 根设备中的超级块被读入内存中,同样,安装其他文件系统时,他们的超级块也读入内存。内存的超级块表
中有些域不出现在磁盘上, 其中包括指定设备打开方式和字节顺序的标志等,此外,内存的超级块表还含有指向位图第一个空闲位的域,
使用这个域可提高访问速度,以及表征超级块所属设备的一个域。实用程序mkfs可用来创建文件系统。我们可以通过像:

```
mkfs /dev/fd1 1440
```

的命令行调用该程序,在驱动器1中的软盘上创建1440个块的空文件系统,这一命令还在超级块中写入魔数,表明该文件系统是一个
有效的MINIX文件系统。此外,我们也可以通过一个原型文件来调用mkfs,其中列出要包含在新文件系统中的目录和文件。MINIX文件
系统经过改进,有些方面(比如i-节点大小)与早期版本不同,魔数还可以表明创建文件系统的mkfs的版本,从而处理他们之间的不同.
MOUNT系统调用检查超级块中魔数和其他信息,可以拒绝安装不是MINIX格式的文件系统,

准备过程
--------------------------------------------------------------------------------

#### 根据机器系统数据(DRIVE_INFO)设置硬盘参数(hd_info):

###### 硬盘参数表(DRIVE_INFO):

\#define DRIVE_INFO (*(struct drive_info*)0x90080)  内存0x90080开始32字节的机器系统数据用于存放硬盘参数表.

###### 硬盘参数描述符:

所有硬盘的参数存放到类型为(struct hd_i_struct)的变量hd_info中

```
struct hd_i_struct {
    int head; // 磁头数
    int sect; // 每磁道扇区数
    int cyl;  // 柱面数
    int wpcom;
    int lzone;
    int ctl;
};
```

###### 硬盘信息描述符:

所有的硬盘信息存放到类型为(struct hd_struct)的变量hd中

```
static struct hd_struct {
    long start_sect;  // 起始扇区
    long nr_sects;    // 总扇区数
};
```

###### 过程:

设置硬盘参数信息是通过调用sys_setup来实现的,具体过程如下:

A. 根据硬盘参数表中的信息设置hd_info

B. 根据hd_info中的硬盘参数描述符中的信息设置hd

#### 读取硬盘引导块.

###### 过程:

读取硬盘引导块是通过在sys_setup中通过向bread函数传递硬盘设备号和块号0(引导块)来读取的,具体过程如下:

A. 调用getblk在缓冲区中申请一个空闲的缓冲块(struct buffer_head).

B. 进入getblk后首先调用get_hash_table查找hash表，检索此前是否有程序把现在要读的硬盘逻辑块
   (相同设备号和块号)已经读到缓冲区.使用hash表的目的是提高查询速度.

C. 进入get_hash_table后调用find_buffer查找缓冲区中是否有指定设备号,块号的缓冲块,如果能找到指定
   缓冲块，就直接用.

#### 从引导块中获取信息