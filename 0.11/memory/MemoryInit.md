内存初始化
================================================================================

当操作系统启动前期实现对于物理内存感知之后,接下来要做的就是对物理内存的管理,要合理的使用。
对于 Linux 这样一个操作系统而言,内存有以下用途:
* 面向进程,要分配给进程用于执行所必要的内存空间;
* 面向文件系统,要为文件缓冲机制提供缓冲区;
* 为虚拟盘机制提供必要的空间。
这三种对于内存的使用相对独立,要实现这一些,就决定了物理内存在使用时需要进行划分,而最简单的
方式就是分块,将内存划分为不同的块,各个块之间各司其职,互不干扰。 linux0.11中就是这样作的。

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/mm_init.png

Linux0.11 将内存分为内核程序、高速缓冲、虚拟盘、主内存四个部分(黑色部分是页目录表、几个
页表,全局描述符表,局部描述符表。一般将他们看作内核的一部分)。

为什么要为内核程序单独划出一个块来呢?
* 主要是为了实现上简单。操作系统作为整个计算机资源的管理者,内核程序起着主要的作用,
  它的代码在操作系统运行时会经常被调用,需要常驻内存。所以将这部分代码与一般进程所使用的空间区分开,
  为他们专门化出一块内存区域。
* 专门划出一块区域还有一个好处,对于内核程序来说, 对于自己的的管理就简单了,内核不用对自己代码进行
  管理。比如: 当内核要执行一个系统调用时,发现相应的代码没有在内存,就必须调用相关的内核代码去将
  这个系统调用的代码加载到内存,在这个过程中,有可能出现再次被调用的相关内核代码不在内存中的情况,
  最后就可能会导致系统崩溃。
  操作系统为了避免这种情况,在内核的设计上就变得复杂了。如果将内核代码专门划一个块出来,将内核代码
  全部载入这个块保护起来,就不会出现上面讲的情况了。

在linux0.11中内存管理主要是对主内存块的管理。
要实现对于这一块的管理,内核就必须对这一块中的每一个物理页面的状态很清楚。
一个物理页面应该有以下基本情况:
* 是否被分配;
* 对于它的存取权限(可读、可写), 是否被访问过, 是否被写过, 被多少个不同对象使用。
对于 linux0.11 来说,后面几个情况可以通过物理页面的页表项的D, A, XW三项得到,
所以对于是否被分配,被多少个对象使用就必须要由内核建立相关数据结构来记录。在linux0.11
定义了一个字符数组mem_map[PAGING_PAGES]用于对主内存区的页面分配和共享信息进行记录。
path: mm/memory.c

```
#define LOW_MEM 0x100000             // 主内存块可能的最低端( 1MB )。
#define PAGING_MEMORY (15*1024*1024) // 主内存区最多可以占用 15M 。
#define PAGING_PAGES (PAGING_MEMORY>>12)    // 主内存块最多可以占用的物理页面数
#define MAP_NR(addr) (((addr)-LOW_MEM)>>12) // 将指定物理内存地址映射为映射数组标号。
#define USED 100 // 页面被占用标志
static unsigned char mem_map [ PAGING_PAGES ] = {0,}; // 主内存块映射数组
```

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/mem_map.png

mem_map中每一项的内容表示物理内存被多少个的对象使用,所以对应项为0就表示对应物理内存页面空闲。
可以看出当内核在定义映射数组mem_map时是以主内存块最大可能大小15M来定义的,最低起始地址为LOW_MEM,
mem_map的第一项对应于物理内存的地址为LOW_MEM,所以就有了映射关系MAP_NR 。而当实际运行时主内存块
却不一定是这么大,这就需要根据实际主内存块的大小对mem_map的内容进行调整。对于不是属于实际主内存块
的物理内存的对应项清除掉, linux0.11采用的做法是在初始化时将实际属于主内存块的物理内存的对应项的
值清零,将不属于的置为一个相对较大的值USED 。这样在作管理时这些不属于主内存块的页面就不会通过
主内存块的管理程序被分配出去使用了。
下面就是主内存块初始化的代码:

path: init/main.c

```
// 当系统初启时,启动程序通过BIOS调用将1M以后的扩展内存大小(KB)读入到内存 0x90002 号单元
#define EXT_MEM_K (*(unsigned short *)0x90002)
...
    // 内存大小 =1Mb 字节 + 扩展内存 (k)*1024 字节。
    memory_end = (1<<20) + (EXT_MEM_K<<10);
    memory_end &= 0xfffff000; // 以页面为单位取整。
    if (memory_end > 16*1024*1024) // linux0.11 最大支持 16M 物理内存
        memory_end = 16*1024*1024;
    if (memory_end > 12*1024*1024) // 根据内存大小设置缓冲区末端的位置
        buffer_memory_end = 4*1024*1024;
    else if (memory_end > 6*1024*1024)
        buffer_memory_end = 2*1024*1024;
    else
        buffer_memory_end = 1*1024*1024;
    // 主内存起始位置 = 缓冲区末端;
    main_memory_start = buffer_memory_end;
#ifdef RAMDISK
    // 如果定义了虚拟盘,重新设置主内存块起始位置
    main_memory_start += rd_init(main_memory_start, RAMDISK*1024);
#endif
    // 初始化主内存块
    mem_init(main_memory_start,memory_end);
```

下面就是 mem_init 的代码:
path: mm/memory.c

```
void mem_init(long start_mem, long end_mem)
{
    int i;

    HIGH_MEMORY = end_mem; // 设置物理内存最高端。
    // 将主内存块映射数组所有项置为 USED
    for (i=0 ; i<PAGING_PAGES ; i++)
        mem_map[i] = USED;
    // 计算实际主内存块物理地址起始位置对应的映射项
    i = MAP_NR(start_mem);
    end_mem -= start_mem; // 计算实际主内存块大小
    end_mem >>= 12;       // 计算需要初始化的映射项数目
    while (end_mem-->0)   // 将实际主内存块对应的映射项置为0(空闲)
        mem_map[i++]=0;
}
```