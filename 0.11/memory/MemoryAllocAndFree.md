内存的分配与回收
================================================================================

分配
--------------------------------------------------------------------------------

当内核本身或者进程需要一页新的物理页面时,内核就要给他分配一个空闲的物理页面。内核需要
查询相关信息,以尽量最优的方案分配一个空闲页面,尤其是在有虚存管理机制的操作系统中对于空闲
页面的选取方案非常重要,如果选取不当将导致系统抖动。 linux0.11没有实现虚存管理,也就不用考虑
这些,只需要考虑如何找出一个空闲页面。

知道了内核对主内存块中空闲物理内存页面的映射结构mem_map,查找空闲页面的工作就简单了。
只需要在mem_map找出一个空闲项,并将该项映射为对应的物理页面地址。算法如下:

```
算法: get_free_page
输入: 无
输出: 空闲页面物理地址
{
    从最后一项开始查找 mem_map 空闲项;
    if( 没有空闲项 )
        renturn 0 ;
    将空闲项内容置 1 ,表示已经被占用;
    将空闲项对应的下标转换为对应的物理页面的物理地址=( 数组下标 <<12 + LOW_MEM)
    将该物理页内容清零
    return 对应的物理地址;
}
```
get_free_page的源码如下:

path: mm/memory.c

```
/*
 * Get physical address of first (actually last :-) free page,
 * and mark it used. If no free pages left, return 0.
 */
// 输入: %1 与 %0 相同表示eax ,初值为0;
//       %2 表示直接操作数(LOW_MEM);
//       %3 表示 ecx ,初值为 PAGING PAGES, 表示搜索次数;
//       %4 表示edi初值为映射数组最后一项地址mem_map+PAGING_PAGES-1 。
// 输出: 返回 %0, 表示 eax 页面起始地址。eax即__res
unsigned long get_free_page(void)
{
    register unsigned long __res asm("ax");

    // 置方向位,将al(0)与(di)开始的反相ecx个字节的内容比较.
    // 第一个是repe和repne,前者是repeat equal,意思是相等的时候重复,后者是repeat not equal,
    // 不等的时候重复;
    // 每循环一次cx自动减一, 所以MOV CX,N; N就是循环次数;
    // 第二个是scasb意思是[al]-[di]，也就是比较查询di中是否有al中的字符，每比较一次di自动变化，
    // 指向上一个或下一个单元, 若di中有x则跳出循环
    __asm__("std ; repne ; scasb\n\t"
            "jne 1f\n\t"            // 如果没有等于0的字节,则跳转结束(返回0)
            "movb $1,1(%%edi)\n\t"  // 将该内存映射项置1
            "sall $12,%%ecx\n\t"    // 相对于LOW_MEM的页面起始地址。sall算法左移<<
            "addl %2,%%ecx\n\t"     // 加上LOW_MEM => 页面实际物理起始地址。
            "movl %%ecx,%%edx\n\t"  // 保存页面实际物理起始地址。
            "movl $1024,%%ecx\n\t"  // 置计数值1024
            "leal 4092(%%edx),%%edi\n\t" // 使edi指向该物理页末端
            "rep ; stosl\n\t"       // 沿反方向将该页清零。
            "movl %%edx,%%eax\n"    // 将页面实际物理起始地址放入eax(返回值)
            "1:"
            :"=a" (__res)
            :"0" (0),"i" (LOW_MEM),"c" (PAGING_PAGES),
             "D" (mem_map+PAGING_PAGES-1)
            );
    return __res; // 返回空闲页面实际物理起始地址(如果无空闲也则返回(0).
}
```

这个函数返回的只是物理页面的物理地址,下一节将具体讲如何将物理地址映射为线性地址。

回收
--------------------------------------------------------------------------------

当内核使用完一个物理页面或者进程退出时内核归还申请了的物理页面。
这时就需要更改相应的信息,以便下一次使用。在归还页面时可能会出现下面几种情况:

* 页面物理地址低于主内存块可能的最低端,这种情况不需要处理直接退出,因为这部分内存空间
  被用于内核程序和缓冲,没有作为分配页面的内存空间。还有一种情况会出现这种情况,当内存
  操作失败时,会调用回收页面过程回收已经分配了的物理页,如果因为内存分配失败造成的,就不
  需要真正的回收操作,调用回收过程时会以0为输入参数。
* 页面物理地址高于实际物理内存最高地址。这种情况是不允许的,内核将使调用对象进入死循环,
  这是一种简单而有效的方法,因为这种情况要判断出错原因是很困难的。
* 调用对象试图释放一块空闲物理内存。出现这种情况可能是因为多个对象共享该物理页,在释放
  时出现了重复释放。比如: 进程A,B共享物理页170,由于系统的原因A将该页释放了两次,当B释放
  该页时就会出现这种情况。这种情况也是不允许的,一般意味着内核出错,内核将使调用对象进入
  死循环以避免错误扩散。
* 要释放的页面正确。因为可能是共享内存,所以要将该页对应的映射项的值减1,表示减少了一个引用对象。
  如果引用数减到0了,并不对物理页面的内容清0,等到被分配时再做,因为可能这个页面不会在被使用,
  同时在分配时用汇编代码来做效率会很高。

这样下面的代码就很好理解了:

path: mm/memory.c

```
/*
 * Free a page of memory at physical address 'addr'. Used by
 * 'free_page_tables()'
 * 释放物理地址'addr'开始的一页内存。用于函数 'free_page_tables()'。
 */
void free_page(unsigned long addr)
{
    if (addr < LOW_MEM) return; // 如果物理地址addr小于主内存块可能的最低端,则返回。
    // 如果物理地址 addr>= 实际内存大小,则显示出错信息,调用对象死机。
    if (addr >= HIGH_MEMORY)
        panic("trying to free nonexistent page");
    // 将物理地址换算为对应的内存映射数组下标。
    addr -= LOW_MEM;
    addr >>= 12;
    // 如果对应内存映射数组项不等于0,则减1,返回
    if (mem_map[addr]--) return;
    // 否则置对应映射项为0,并显示出错信息,调用对象死机。
    mem_map[addr]=0;
    panic("trying to free free page");
}
```