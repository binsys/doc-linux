Linux 0.11 保护模式下对物理内存的管理
================================================================================

保护模式在硬件上为实现虚拟存储创造了条件,但是内存的管理还是要由软件来做。操作系统作为
资源的管理者,当然要对内存的管理就要由它来做了。

在386保护模式下,对任何一个物理地址的访问都要通过页目录表和页表的映射机制来间接访问,
而程序提供的任何地址信息都会被当成线性地址进行映射,这就使得地址提供者不知道他所提供的线性
地址最后被映射到了哪个具体的物理地址单元。这样的措施使得用户程序不能随意地操作物理内存,提
高了系统的安全性,但是也给操作系统管理物理内存造成了障碍。而操作系统必须要了解物理内存的使
用情况才谈得上管理。

要能够在保护模式下感知物理内存,也就是说要能够避开保护模式下线性地址的影响,直接对物理内存进行操作。
如何避开呢?
正如前面所说: 在保护模式下对任何一个物理地址的访问都要通过对线性地址的映射来实现。

不可能绕过这个映射机制,那只有让他对内核失效。如果让内核使用的线性地址和物理地址重合,
比如: 当内核使用 0x0000 1000 这个线性地址时访问到的就是物理内存中的 0x00001000 单元。问题不就解决了吗!
linux0.11 中采用的正是这种方法。

在进入保护模式之前,要初始化页目录表和页表,以供在切换到保护模式之后使用,要实现内核
线性地址和物理地址的重合,必须要在这个时候在页目录表和页表上做文章。

在看代码之前首先说明几点:
由于 linus 当时编写程序时使用的机器只有 16M 的内存,所以程序中也只处理了 16M 物理内存的情况,
而且只考虑了 4G 线性空间的情况。一个页表可以寻址 4M 的物理空间,所以只需要4个页表,
一个页目录表可以寻址 4G 的线性空间,所以只需要 1 个页目录表。

程序将页目录表放在物理地址_pg_dir=0x0000处, 4个页表分别放在
 pg0=0x1000, pg1=0x2000,pg2=0x3000, pg3=0x4000 处
下面是最核心的几行代码:

path: boot/head.s

```
.text
.globl idt,gdt,pg_dir,tmp_floppy_area,startup_32
pg_dir:     # pg_dir is at 0x000
startup_32:
...
.org 0x1000
pg0:

.org 0x2000
pg1:

.org 0x3000
pg2:

.org 0x4000
pg3:
...
/* 首先对 5 页内存清零 */
setup_paging:
    movl $1024*5,%ecx # 设置填充次数 ecx=1024*5 /* 5 pages - pg_dir+4 page tables */
    xorl %eax,%eax    # 设置填充到内存单元中的数 eax=0
    xorl %edi,%edi    /* pg_dir is at 0x000 */ #设置填充的起始地址0,也是页目录表的起始位置
    /* STOSL指令相当于将EAX中的值保存到ES:EDI指向的地址中，若设置了EFLAGS中的方向
     * 位置位(即在STOSL指令前使用STD指令)则EDI自减4，否则(使用CLD指令)EDI自增
     */
    cld;rep;stosl
    /* 下面填写页目录表的页目录项对于4个页目录项,将属性设置为用户可读写, 存在于物理内存,
     * 所以页目录项的低12位是0000 0000 0111.
     * 以第一个页目录项为例:
     * $pg0+7 = 0x0000 1007表示第一个页表的物理地址是0x0000 1007 & 0xffff f000 = 0x0000 1000;
     * 权限是 0x0000 1007 & 0x0000 0fff = 0x0000 0007
     */
    movl $pg0+7,pg_dir     /* set present bit/user r/w */
    movl $pg1+7,pg_dir+4   /* --------- " " --------- */
    movl $pg2+7,pg_dir+8   /* --------- " " --------- */
    movl $pg3+7,pg_dir+12  /* --------- " " --------- */
    /* 接着便是对页表的设置:
     * 4个页表×1024个页表项×每个页表项寻址4K, 物理空间: 4*1024*4*1024=16M
     * 每个页表项的内容是: 当前项所映射的物理内存地址 + 该页的权限
     * 其中该页的属性仍然是用户可读写,存在于物理内存,即 0x0000 0007
     * 具体的操作是从 16M 物理空间的最后一个页面开始逆序填写页表项:
     * 最后一个页面的起始物理地址是 0x0xfff000,加上权限位便是 0x fff007,
     * 以后每减 0x1000(一个页面的大小)便是下一个要填写的页表项的内容。
     */
    movl $pg3+4092,%edi  # edi指向第四个页表的最后一项4096-4。
    # 0xffffff --> 16MB
    movl $0xfff007,%eax  /* 16Mb - 4096 + 7 (r/w user,p) */ #把第四个页表的最后一项的内容放进eax
    std # 置方向位,edi 值以 4 字节的速度递减。
1:  stosl /* fill pages backwards - more efficient :-) */
    subl $0x1000,%eax # 每填写好一项,物理地址值减 0x1000。
    jge 1b # 如果 eax 小于0则说明全填写好了。
    xorl %eax,%eax /* pg_dir is at 0x0000 */ # 令 eax=0x0000 0000(页目录表基址)
    movl %eax,%cr3 # 使页目录表基址寄存器 cr3 指向页目录表。/* cr3 - page directory start */
    # 设置 cr0 的 PG 标志(位 31),启动保护模式
    movl %cr0,%eax
    orl $0x80000000,%eax  # 添上 PG 标志位。
    movl %eax,%cr0
   /* set paging (PG) bit */
```

在分析完这段代码之后,应该对初始化后的页目录表和页表有了一个大概的了解了,
当这段代码运行完后内存中的映射关系应该如图所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/setup_paging.png

接下来将内核代码段描述符gdt设置为:

```
gdt:
    .quad 0x0000000000000000    /* NULL descriptor */
    .quad 0x00c09a0000000fff    /* 16Mb */ # 代码段最大长度 16M。
    .quad 0x00c0920000000fff    /* 16Mb */
    .quad 0x0000000000000000    /* TEMPORARY - don't use */
    .fill 252,8,0               /* space for LDT's and TSS's etc */
```
这样线性地址就和物理地址重合了。

下面用两个例子验证一下:

### Example 1:

要寻找pg_dir的第15项的内容这个地址应该是在页目录表的(15-1)*4=0x38 位置,把它写成32位地址是0x0000 0038,
当内核使用这个地址时,仍然要通过映射:
首先取高10位,0000 0000 00, 页目录表第0项的内容是$pg0+7,得到页表地址是pg0=0x0000 1000,
CPU将用这个地址加上偏移量找到对应的页表项,偏移量=线性地址中间10位*4=0,
在pg0中偏移量为0的页表项为 0x0000 0007, CPU 得到页表地址是 0x0000 0000 加上线性地址
的最后12位,将找到 0x0000 0038 单元的内容。

### Example 2:

寻找任意物理单元0x00f5 9f50与第一个例子一样

用这个地址作为线性地址寻址, 先用高10位寻找页表,页目录表第"0000 0000 11"项指向 pg3,
根据线性地址中间10位"11 0101 1001"寻找页表项, pg3的第"11 0101 1001"应该是"0x00f5 9007",
取得页表基址"0x00f5 9000", 加上页内偏移量 0xf50, 最后得到的就是物理地址 0x00f5 9f50 的内容。
从上面两个例子可以看出:内核中使用的线性地址实际上已经是物理地址,这样从现象上看 386 的地址映射机制对内核失效了.