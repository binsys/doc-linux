页面异常
================================================================================

当cpu在进行内存访问时,可能因为缺页或者试图对一个只读页面进行写操作而产生页面异常,
cpu进入相应的页面异常中断处理程序。
由于异常可能由缺页或者写只读页面产生,两种情况的处理也是不同的,所以中断处理程序首先应该
区分产生本次异常的原因,进入不同的处理过程。算法如下:

```
算法: page_fault
输入: 出错码 error_code; 出错线性地址 address
输出: 无
{
    保存现场;
    根据出错码判断出错原因;
    if (缺页)
        作缺页处理 do_no_page(error_code, address);
    else
        作写保护出错处理 do_wp_page(error_code, address) ;
    恢复现场;
    return ;
}
```

在x86处理器中error_code由cpu产生并在保存了中断点的相关内容之后将其压入堆栈,出错码的
最低位指示出错原因(1: 写出错; 0: 缺页)。 address 则是由一个专门的32位寄存器cr2保存。
具体代码如下:

mm/page.s
```
.globl page_fault

page_fault:
    xchgl %eax,(%esp)  // 交换eax与esp所指向空间的内容 => 1.保存eax; 2.取出error_code
    // 保存现场
    pushl %ecx
    pushl %edx
    push %ds
    push %es
    push %fs
    // 使ds,es,fs指向系统数据段
    movl $0x10,%edx
    mov %dx,%ds
    mov %dx,%es
    mov %dx,%fs

    // 取出错线性地址
    // CR2用于出现页异常时报告出错信息。在报告页异常时，处理器会把引起异常的线性地址存放在CR2中。
    // 因此操作系统中的页异常处理程序可以通过检查CR2的内容来确定线性地址空间中哪一个页面引发了异常。
    movl %cr2,%edx
    // 将出错地址和出错码压入堆栈,作为处理函数的输入参数
    pushl %edx
    pushl %eax
    // 判断出错码最低位,决定调用函数
    testl $1,%eax
    jne 1f          // 为1 ,调用写保护出错处理函数
    call do_no_page // 为0, 调用缺页处理函数
    jmp 2f
1:  call do_wp_page
2:  addl $8,%esp  // 丢弃输入参数 error_code 和 address
    // 恢复现场
    pop %fs
    pop %es
    pop %ds
    popl %edx
    popl %ecx
    popl %eax
    iret
```

在这段代码中,我们可以充分领略到系统程序员对汇编编程知识的要求。 在"xchgl %eax,(%esp)",
必须非常清楚压栈过程。当cpu执行压栈操作时,是先执行esp=esp-4; 再将数据送入esp所指向的单元。
cpu 在进入异常中断处理程序之前,将error_code压入了堆栈,当前 esp 指向的单元存放的就是error_code,
所以上述命令,取出了error_code又将eax保存了,如果要用其他方法实现应该是:

```
pushl eax
movl (esp+4),eax
```

相比之下, 改行的程序将eax放在了error_code 原来存放的空间,节约了堆栈空间,同时也节约指令数,
可谓是一箭四雕。"2: addl $8,%esp" 对于输入参数的丢弃,不是用两次popl操作,而是直接将esp加8 ,
又省了一条指令。可见高水平的系统程序员为了提高效率是多么的抠门。这样的程序虽然效率高,
但是对于理解会有一定的障碍,不过换个方向来想,毕竟这种底层代码不是人人都会去仔细读的。

当处理器在转换线性地址到物理地址的过程中检测到以下两种条件时,就会发生页异常中断,中断14。
* 当 CPU 发现对应页目录项或页表项的存在位( Present )标志为 0 。
* 当前进程没有访问指定页面的权限。

对于页异常处理中断, CPU提供了两项信息用来诊断页异常和从中恢复运行。

(1). 放在堆栈上的出错码。该出错码指出了异常是由于页不存在引起的还是违反了访问权限引起的;
在发生异常时 CPU 的当前特权层;以及是读操作还是写操作。出错码的格式是一个32位的长字。
但只用了最后的 3 个比特位。分别说明导致异常发生时的原因:

* 位 2(U/S) - 0 表示在超级用户模式下执行, 1 表示在用户模式下执行;
* 位 1(W/R) - 0 表示读操作, 1 表示写操作;
* 位 0(P) - 0 表示页不存在, 1 表示页级保护。

(2). CR2(控制寄存器2)。CPU 将造成异常的用于访问的线性地址存放在CR2中。异常处理程序可以
使用这个地址来定位相应的页目录和页表项。如果在页异常处理程序执行期间允许发生另一个
页异常,那么处理程序应该将 CR2 压入堆栈中。

缺页中断
--------------------------------------------------------------------------------

在对进行进程初始设置时,内核并不是将进程可能用到的所有内存一次性分配给进程,而是在进程
要访问该地址时分配,将内存分配给一定会被访问的空间,这样就提高内存资源的使用率。这样作就不可避免
地会出现缺页中断。当 cpu 访问一个内存单元时,如果该单元所在的页面不在内存中, cpu将产生页面异常,
进一步进入缺页处理程序,算法如下:

```
算法: do_no_page
输入: 出错码 error_code; 出错线性地址 address
输出: 无
{
    if ( 出错进程没有对应的可执行文件
       || 出错地址不在代码和数据段 )
    {
        分配物理页面并映射到出错线性地址 ( 使用 get_empty_page()) ;
        return;
    }
    试图共享页面(使用 share_page()) ;
    if (共享页面成功)
        return;
    分配新的物理页面 (get_free_page() ) ;
    从可执行文件中将页面对应的内容读入内存;
    将页面中不属于代码段和数据段的内容清零;
    将新的物理页面映射到出错线性地址(put_page()) ;
    if ( 映射失败 )
    {
        释放新申请的物理页面;
        显示出错,死循环;
    }
    return;
}
```

进程在不同的时刻会处于不同的状态,如果进程此时还处于初始化时期,就可能还没有设置对应的
可执行文件,这个时候的内存使用请求可能是与其设置有关的,所以需要为其分配内存。
对于进程的可执行文件,在这里只是说一下它的基本结构:

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/exec.png

进程对应的可执行文件包含有进程的代码段和数据段的内容,进程的线性地址与可执行文件内容的
逻辑地址是对应的,如果出错是在代码段和数据段,应该先试图共享内存,共享不成功就应该分配
内存并从可执行文件中读取相应内容; 如果不是在这两个段,就直接分配内存。

可执行文件存储在磁盘上,磁盘的存储基本单位是1KB,所以要读取一个页面的内容就要读取四个磁盘块。
从可执行文件中读取内容由bmap和bread_page两个函数来作,首先将出错线性地址所在页面换算成可执行文件
对应的逻辑盘块号, bmap用于将逻辑盘块号换算成物理盘块号, 最后由bread_page将四个物理盘块读入内存。

在读入过程中,可能出现这种情况,由于线性地址太大,对应页面换算得到的逻辑盘块号过大,对应可执行文件
却没有这么大(如下所示,这时后两块逻辑盘块将不会被读入),多余的逻辑盘将不会被读入。

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/line_larger.png

另外,读入一页内存之后,该页的结束地址可能会超过end_data。由于上述两种情况,应该对多出来的内存清零。
最后就是映射页面, put_page 只有在申请新的页表空间失败的情况会返回 0 ,这时就应该将已经申请
了的物理页面释放,然后调用 oom() 报错。
具体代码如下: