Linux 0.11 安装页目录和页表
================================================================================

保护模式在硬件上为实现虚拟存储创造了条件,但是内存的管理还是要由软件来做。操作系统作为
资源的管理者,当然要对内存的管理就要由它来做了。

在386保护模式下,对任何一个物理地址的访问都要通过页目录表和页表的映射机制来间接访问,
而程序提供的任何地址信息都会被当成线性地址进行映射,这就使得地址提供者不知道他所提供的线性
地址最后被映射到了哪个具体的物理地址单元。这样的措施使得用户程序不能随意地操作物理内存,提
高了系统的安全性,但是也给操作系统管理物理内存造成了障碍。而操作系统必须要了解物理内存的使
用情况才谈得上管理。

要能够在保护模式下感知物理内存,也就是说要能够避开保护模式下线性地址的影响,直接对物理内存进行操作。
如何避开呢?
正如前面所说: 在保护模式下对任何一个物理地址的访问都要通过对线性地址的映射来实现。

不可能绕过这个映射机制,那只有让他对内核失效。如果让内核使用的线性地址和物理地址重合,
比如: 当内核使用0x0000 1000这个线性地址时访问到的就是物理内存中的0x0000 1000单元。
问题不就解决了吗!
linux0.11 中采用的正是这种方法。

在进入保护模式之前,要初始化页目录表和页表,以供在切换到保护模式之后使用,要实现内核
线性地址和物理地址的重合,必须要在这个时候在页目录表和页表上做文章。

在看代码之前首先说明几点:
由于 linus 当时编写程序时使用的机器只有 16M 的内存,所以程序中也只处理了 16M 物理内存的情况,
而且只考虑了 4G 线性空间的情况。一个页表可以寻址 4M 的物理空间,所以只需要4个页表,
一个页目录表可以寻址 4G 的线性空间,所以只需要 1 个页目录表。

程序将页目录表放在物理地址"pg_dir=0x0000"处, 4个页表分别放在
"pg0=0x1000, pg1=0x2000,pg2=0x3000, pg3=0x4000"处
下面是最核心的几行代码:

path: boot/head.s

```
.text
.globl idt,gdt,pg_dir,tmp_floppy_area,startup_32
pg_dir:     # pg_dir is at 0x000
startup_32:
...
.org 0x1000
pg0:

.org 0x2000
pg1:

.org 0x3000
pg2:

.org 0x4000
pg3:
...
/* 首先对 5 页内存清零 */
setup_paging:
    movl $1024*5,%ecx # 设置填充次数 ecx=1024*5 /* 5 pages - pg_dir+4 page tables */
    xorl %eax,%eax    # 设置填充到内存单元中的数 eax=0
    xorl %edi,%edi    /* pg_dir is at 0x000 */ #设置填充的起始地址0,也是页目录表的起始位置
    /* STOSL指令相当于将EAX中的值保存到ES:EDI指向的地址中，若设置了EFLAGS中的方向
     * 位置位(即在STOSL指令前使用STD指令)则EDI自减4，否则(使用CLD指令)EDI自增
     */
    cld;rep;stosl
    /* 下面填写页目录表的页目录项对于4个页目录项,将属性设置为用户可读写, 存在于物理内存,
     * 所以页目录项的低12位是0000 0000 0111.
     * 以第一个页目录项为例:
     * $pg0+7 = 0x0000 1007表示第一个页表的物理地址是0x0000 1007 & 0xffff f000 = 0x0000 1000;
     * 权限是 0x0000 1007 & 0x0000 0fff = 0x0000 0007
     */
    movl $pg0+7,pg_dir     /* set present bit/user r/w */
    movl $pg1+7,pg_dir+4   /* --------- " " --------- */
    movl $pg2+7,pg_dir+8   /* --------- " " --------- */
    movl $pg3+7,pg_dir+12  /* --------- " " --------- */
    /* 接着便是对页表的设置:
     * 4个页表×1024个页表项×每个页表项寻址4K, 物理空间: 4*1024*4*1024=16M
     * 每个页表项的内容是: 当前项所映射的物理内存地址 + 该页的权限
     * 其中该页的属性仍然是用户可读写,存在于物理内存,即 0x0000 0007
     * 具体的操作是从 16M 物理空间的最后一个页面开始逆序填写页表项:
     * 最后一个页面的起始物理地址是 0x0xfff000,加上权限位便是 0x fff007,
     * 以后每减 0x1000(一个页面的大小)便是下一个要填写的页表项的内容。
     */
    movl $pg3+4092,%edi  # edi指向第四个页表的最后一项4096-4。
    # 0xffffff --> 16MB
    movl $0xfff007,%eax  /* 16Mb - 4096 + 7 (r/w user,p) */ #把第四个页表的最后一项的内容放进eax
    std # 置方向位,edi 值以 4 字节的速度递减。
1:  stosl /* fill pages backwards - more efficient :-) */
    subl $0x1000,%eax # 每填写好一项,物理地址值减 0x1000。
    jge 1b # 如果 eax 小于0则说明全填写好了。
    xorl %eax,%eax /* pg_dir is at 0x0000 */ # 令 eax=0x0000 0000(页目录表基址)
    movl %eax,%cr3 # 使页目录表基址寄存器 cr3 指向页目录表。/* cr3 - page directory start */
    # 设置 cr0 的 PG 标志(位 31),启动分页模式.
    movl %cr0,%eax
    orl $0x80000000,%eax  # 添上 PG 标志位。
    movl %eax,%cr0   /* set paging (PG) bit */
```

在分析完这段代码之后,应该对初始化后的页目录表和页表有了一个大概的了解了,
当这段代码运行完后内存中的映射关系应该如图所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/setup_paging.png

接下来将内核代码段描述符gdt设置为:

```
gdt:
    .quad 0x0000000000000000    /* NULL descriptor */
    .quad 0x00c09a0000000fff    /* 16Mb */ # 代码段最大长度 16M。
    .quad 0x00c0920000000fff    /* 16Mb */
    .quad 0x0000000000000000    /* TEMPORARY - don't use */
    .fill 252,8,0               /* space for LDT's and TSS's etc */
```
这样线性地址就和物理地址重合了。

下面用两个例子验证一下:

### Example 1:

要寻找pg_dir的第15项的内容这个地址应该是在页目录表的(15-1)*4=0x38 位置,把它写成32位地址是0x0000 0038,
当内核使用这个地址时,仍然要通过映射:
首先取高10位,0000 0000 00, 页目录表第0项的内容是$pg0+7,得到页表地址是pg0=0x0000 1000,
CPU将用这个地址加上偏移量找到对应的页表项,偏移量=线性地址中间10位*4=0,
在pg0中偏移量为0的页表项为 0x0000 0007, CPU 得到页表地址是 0x0000 0000 加上线性地址
的最后12位,将找到 0x0000 0038 单元的内容。

### Example 2:

寻找任意物理单元0x00f5 9f50与第一个例子一样

用这个地址作为线性地址寻址, 先用高10位寻找页表,页目录表第"0000 0000 11"项指向 pg3,
根据线性地址中间10位"11 0101 1001"寻找页表项, pg3的第"11 0101 1001"应该是"0x00f5 9007",
取得页表基址"0x00f5 9000", 加上页内偏移量 0xf50, 最后得到的就是物理地址 0x00f5 9f50 的内容。
从上面两个例子可以看出:内核中使用的线性地址实际上已经是物理地址,这样从现象上看 386 的地址映射机制对内核失效了.

补充知识:
--------------------------------------------------------------------------------

在 Intel 80x86 的系统中,内存分页管理是通过页目录表和内存页表所组成的二级表进行的。
见下图所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/two_step_table.png

其中页目录表和页表的结构是一样的,表项结构也相同。页目录表中的每个表项(简称页目录项)
(4字节)用来寻址一个页表,而每个页表项(4字节)用来指定一页物理内存页。因此,当指定了一个
页目录项和一个页表项,我们就可以唯一地确定所对应的物理内存页。页目录表占用一页内存,因此最
多可以寻址 1024 个页表。而每个页表也同样占用一页内存,因此一个页表可以寻址最多 1024 个物理内
存页面。这样在 80386 中,一个页目录表所寻址的所有页表共可以寻址 1024 X 1024 X 4096 = 4G 的内存
空间。在 Linux 0.11 内核中,所有进程都使用一个页目录表,而每个进程都有自己的页表。
对于应用进程或内核其它部分来讲,在申请内存时使用的是线性地址。

接下来我们就要问了: “那么,一个线性地址如何使用这两个表来映射到一个物理地址上呢?”。
为了使用分页机制,一个 32 位的线性地址被分成了三个部分,分别用来指定一个页目录项、
一个页表项和对应物理内存页上的偏移地址,从而能间接地寻址到线性地址指定的物理内存位置。
见下图所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/line_to_pyh.png

线性地址的位31-22共10个比特用来确定页目录中的目录项,位21-12用来寻址页目录项指定的页表中的页表项,
最后的 12 个比特正好用作页表项指定的一页物理内存中的偏移地址。

在内存管理的函数中,大量使用了从线性地址到实际物理地址的变换计算。对于给定一个进程的线性地址,
通过上图中所示的地址变换关系,我们可以很容易地找到该线性地址对应的页目录项。若该目录项有效(被使用),
则该目录项中的页框地址指定了一个页表在物理内存中的基址,那么结合线性地址中的页表项指针,若该页表项有效,
则根据该页表项中的指定的页框地址,我们就可以最终确定指定线性地址对应的实际物理内存页的地址。
反之,如果需要从一个已知被使用的物理内存页地址,寻找对应的线性地址,则需要对整个页目录表和所有
页表进行搜索。若该物理内存页被共享,我们就可能会找到多个对应的线性地址来。

下图用形象的方法示出了一个给定的线性地址是如何映射到物理内存页上的。

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/how_line_to_pyh.png

对于第一个进程(任务0),其页表是在页目录表之后,共4页。对于应用程序的进程,
其页表所使用的内存是在进程创建时向内存管理程序申请的,因此是在主内存区中.
一个系统中可以同时存在多个页目录表,而在某个时刻只有一个页目录表可用。
当前的页目录表是用CPU的寄存器CR3来确定的,它存储着当前页目录表的物理内存地址。
但在此所讨论的 Linux 内核中只使用了一个页目录表。每个页表项对应的物理内存页在4G
的地址范围内是随机的,是由页表项中页框地址内容确定的,也即是由内存管理程序通过
设置页表项确定的。每个表项由页框地址、访问标志位、脏(已改写)标志位和存在标志位等构成。
表项的结构可参见下图所示:

https://github.com/leeminghao/doc-linux/blob/master/0.11/memory/table_item.png

其中,
* 页框地址 (PAGE FRAME ADDRESS) 指定了一页内存的物理起始地址。因为内存页是位于4K边界上的,
  所以其低12比特总是0,因此表项的低 12 比特可作它用。在一个页目录表中,表项的页框地址是
  一个页表的起始地址;在第二级页表中,页表项的页框地址则包含期望内存操作的物理内存页地址。
* 图中的存在位( PRESENT – P )确定了一个页表项是否可以用于地址转换过程。 P=1 表示该项可用。
  当目录表项或第二级表项的 P=0 时,则该表项是无效的,不能用于地址转换过程。此时该表项的所有
  其它比特位都可供程序使用;处理器不对这些位进行测试。
* 当 CPU 试图使用一个页表项进行地址转换时,如果此时任意一级页表项的 P=0 ,则处理器就会发出
  页异常信号。此时缺页中断异常处理程序就可以把所请求的页加入到物理内存中,并且导致异常的
  指令会被重新执行。
* 已访问( Accessed – A )和已修改( Dirty – D )比特位用于提供有关页使用的信息。除了页目录项中
  的已修改位,这些比特位将由硬件置位,但不复位。
  在对一页内存进行读或写操作之前, CPU将设置相关的目录和二级页表项的已访问位。在向一个二级页表项
  所涵盖的地址进行写操作之前,处理器将设置该二级页表项的已修改位,而页目录项中的已修改位是不用的。
  当所需求的内存超出实际物理内存量时,内存管理程序就可以使用这些位来确定那些页可以从内存中取走,
  以腾出空间。内存管理程序还需负责检测和复位这些比特位。
* 读/写位( Read/Write – R/W )和用户/超级用户位(User/Supervisor – U/S)并不用于地址转换,
  但用于分页级的保护机制,是由 CPU 在地址转换过程中同时操作的。